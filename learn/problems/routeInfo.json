{"path":"learn/problems","templateID":2,"sharedPropsHashes":{},"localProps":{"node":{"route":"problems","text":"Problems","children":[{"route":"arrays","text":"Arrays","children":[{"text":"Spiral","slug":"arrays-spiral","fullPath":"/learn/problems/arrays/arrays-spiral","content":{"title":"Go through matrix in a spiral","slug":"arrays-spiral","contents":"<h3 id=\"complexity\">Complexity</h3>\n<p>O(N) time + O(N) space for path.</p>\n<h3 id=\"solution\">Solution</h3>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static int[] spiral(int[][] matrix) {\n        int col = matrix.length / 2;\n        int row = matrix.length / 2;\n        int[] path = new int[matrix.length * matrix.length];\n        int pathIdx = 0;\n        path[pathIdx] = matrix[col][row];\n\n        for (int subSize = 3; subSize &lt;= matrix.length; subSize += 2) {\n\n            // Go 1 step left.\n            path[++pathIdx] = matrix[row][--col];\n\n            // Go down all the way.\n            for (int i = 0; i &lt; subSize - 2; i++) {\n                path[++pathIdx] = matrix[++row][col];\n            }\n\n            // Go right all the way.\n            for (int i = 0; i &lt; subSize - 1; i++) {\n                path[++pathIdx] = matrix[row][++col];\n            }\n\n            // Go up all the way.\n            for (int i = 0; i &lt; subSize - 1; i++) {\n                path[++pathIdx] = matrix[--row][col];\n            }\n\n            // Go left all the way.\n            for (int i = 0; i &lt; subSize - 1; i++) {\n                path[++pathIdx] = matrix[row][--col];\n            }\n        }\n        return path;\n    }\n}\n</code></pre>\n"}},{"text":"Sum of two","slug":"arrays-sum-of-two","fullPath":"/learn/problems/arrays/arrays-sum-of-two","content":{"title":"Sum of two elements","slug":"arrays-sum-of-two","contents":"<h3 id=\"description\">Description</h3>\n<p>Given an array of integers and a sum, return indices of the two numbers such that they add up to the sum.</p>\n<h3 id=\"complexity\">Complexity</h3>\n<p>O(N) time + O(N) space for the HashMap.</p>\n<h3 id=\"solution\">Solution</h3>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static Optional&amp;lt;int[]&amp;gt; findSumIndices(int[] numbers, int sum) {\n        Map&amp;lt;Integer, Integer&amp;gt; numToIndex = new HashMap&lt;&gt;();\n\n        for (int i = 0; i &lt; numbers.length; i++) {\n            int wanted = sum - numbers[i];\n            if (numToIndex.containsKey(wanted)) {\n                return Optional.of(new int[] { numToIndex.get(wanted), i });\n            }\n\n            numToIndex.put(numbers[i], i);\n        }\n        return Optional.empty();\n    }\n}\n</code></pre>\n"}}],"fullPath":"/learn/problems/arrays"},{"route":"hashtable","text":"Hashtable","children":[{"text":"Implement","slug":"hashtable-implement","fullPath":"/learn/problems/hashtable/hashtable-implement","content":{"title":"Implement a hashtable","slug":"hashtable-implement","contents":"<h3 id=\"solution\">Solution</h3>\n<p>Implement a generic Hashnode&lt;K, V&gt; class and store hashtable in a Hashnode&lt;K, V&gt;[]. Handle collisions by making linked lists (linear probing).</p>\n<h3 id=\"discussion\">Discussion</h3>\n<p><em>Linear vs. quadratic probing</em></p>\n<p>a.  Linear probing leads to bigger clusters, and clusters reduce speed. A bad hash function can lead to\nreally nasty clusters. However, with a good hash function which is good at avoiding collisions, linear\nprobing is faster due to cache locality.</p>\n<p>b.  Quadratic probing reduces cluster size, and this is good for speed, if you have problems with\ncollisions. If you don’t, then it’s slower.</p>\n<p><em>Power-of-two vs. prime size</em></p>\n<p>a.  Prime table size spreads out the keys more evenly in the table which avoids clustering. Clustering makes\nthe algorithm slow, especially with linear probing.</p>\n<p>b.  Power-of-two table size does not spread out as good as a prime table with a bad hash function. However,\na good one will spread well anyway, and we can avoid using modulo operations (expensive) and use a cheaper\noperation (bit mask).</p>\n<pre><code class=\"lang-java\">/*\n * A power-of-two hashtable using linear probing.\n */\npublic class HashTable&amp;lt;K, V&amp;gt; {\n\n    // 16 and 0.75 taken from real HashMap.\n    private static final int INITIAL_CAPACITY = 16;\n    private static final double LOAD_FACTOR = 0.75;\n    private HashNode&amp;lt;K, V&amp;gt;[] table;\n    private int size;\n\n    public HashTable() {\n        table = new HashNode[INITIAL_CAPACITY];\n        size = 0;\n    }\n\n    public V get(K key) {\n        int index = hashIndex(key);\n\n        for (Hashnode&amp;lt;K, V&amp;gt; node = table[index]; node != null; node = node.next) {\n            if (key.equals(node.key)) {\n                return node.value;\n            }\n        }\n        return null;\n    }\n\n    public void put(K key, V value) {\n        if (size &gt;= LOAD_FACTOR * table.length) {\n            resize();\n        }\n\n        int index = hashIndex(key);\n        Hashnode&amp;lt;K, V&amp;gt; newNode = new Hashnode&amp;lt;&gt;(key, value);\n\n        if (table[index] == null) {\n            table[index] = newNode;\n        } else {\n            Hashnode&amp;lt;K, V&amp;gt; node = table[index];\n            while (node.next != null) {\n                node = node.next;\n            }\n            node.next = newNode;\n        }\n        size++;\n    }\n\n    private void resize() {\n        HashNode[] newTable = new HashNode[table.length * 2];\n\n        for (int i = 0; i &lt; table.length; i++) {\n            newTable[i] = table[i];\n        }\n\n        table = newTable;\n    }\n\n    private int hashIndex(K key) {\n        int h = 0;\n        h = key.hashCode() ^ (h &gt;&gt;&gt; 16);\n\n        // To find a bucket from a hash --&gt; use AND instead of modulo (expensive).\n        return (table.length - 1) &amp; h;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    private class HashNode&amp;lt;K, V&amp;gt; {\n\n        private HashNode&amp;lt;K, V&amp;gt; next;\n        private K key;\n        private V value;\n\n        public HashNode(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}\n</code></pre>\n"}}],"fullPath":"/learn/problems/hashtable"},{"route":"linked-list","text":"Linked list","children":[{"text":"Cycle","slug":"linked-list-cycle","fullPath":"/learn/problems/linked-list/linked-list-cycle","content":{"title":"Detect a cycle in a linked list","slug":"linked-list-cycle","contents":"<h3 id=\"okay-solution\">Okay solution</h3>\n<p>Go through list one by one and check if already visited with a HashSet.</p>\n<p>Complexity –&gt; O(N) time and O(N) space.</p>\n<h3 id=\"best-solution\">Best solution</h3>\n<p>Go through list with fast and slow runner. Slow runner takes one node at a time, fast takes two. If fast catches up with slow, it’s a cycle. If fast comes to the end (null), it’s not a cycle.</p>\n<p>Complexity –&gt; O(N) time and O(1) space.</p>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean hasCycle(Node startNode) {\n        Set&amp;lt;Integer&amp;gt; visited = new HashSet&lt;&gt;();\n\n        Node current = startNode;\n        while (current.getNext() != null) {\n            if (visited.contains(current.getId())) {\n                return true;\n            }\n\n            visited.add(current.getId());\n            current = current.getNext();\n        }\n        return false;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean hasCycle(Node startNode) {\n        Node slow = startNode;\n        Node fast = startNode;\n\n        while (fast != null &amp;&amp; fast.getNext() != null) {\n            slow = slow.getNext();\n            fast = fast.getNext().getNext();\n\n            if (fast == slow) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Node {\n\n    private final Integer id;\n    private Node next;\n\n    public Node(Integer id) {\n        this.id = id;\n    }\n\n    public Node getNext() {\n        return next;\n    }\n\n    public Integer getId() {\n        return id;\n    }\n}\n</code></pre>\n"}},{"text":"Delete","slug":"linked-list-delete","fullPath":"/learn/problems/linked-list/linked-list-delete","content":{"title":"Delete a node in a linked list","slug":"linked-list-delete","contents":"<h3 id=\"solution-1-root-is-given-\">Solution #1 (root is given)</h3>\n<p>If root is given, we can loop to the previous node and set its next node to the node after the deleted node. The node will then be garbage collected.</p>\n<p>Bad argument: Delete node doesn’t exist.\nBad argument: Delete node is the only node in the list.\nSpecial case: Delete node is root.</p>\n<h3 id=\"solution-2-root-is-not-given-\">Solution #2 (root is not given)</h3>\n<p>We can only solve this with a more “ugly” solution - we’ll swap Node values. If Node id’s are final, we have to mess up the id’s. If not final, we could swap both values and id’s.</p>\n<p>NOTE: we must assume given node is not the tail.</p>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static Node delete(Node root, Node node) {\n\n        // Special case: we want to delete root node.\n        if (node == root) {\n            if (root.getNext() == null) {\n                throw new IllegalArgumentException(&quot;Can&#39;t delete only node in list.&quot;);\n            }\n            Node newRoot = root.getNext();\n            root.setNext(null);\n            return newRoot;\n        }\n\n        // Other case: node is in middle or the last node.\n        Node previous = root;\n        while (previous != null &amp;&amp; previous.getNext() != node) {\n            previous = previous.getNext();\n        }\n\n        if (previous == null) {\n            throw new IllegalArgumentException(&quot;Given node does not exist in list.&quot;);\n        }\n\n        // Node will be garbage collected.\n        previous.setNext(node.getNext());\n        return root;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    /**\n     * Only handles nodes that aren&#39;t the tail.\n     * Also messes up id&#39;s since it only swaps values, not actual nodes.\n     */\n    public static void delete(Node node) {\n        if (node == null || node.getNext() == null) {\n            throw new IllegalArgumentException(&quot;Bad argument.&quot;);\n        }\n\n        node.setValue(node.getNext().getValue());\n        node.setNext(node.getNext().getNext());\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Node {\n\n    private final int id;\n    private Node next;\n    private int value;\n\n    public Node(int id, int value) {\n        this.id = id;\n        this.value = value;\n    }\n\n    public Node getNext() {\n        return next;\n    }\n\n    public void setNext(Node next) {\n        this.next = next;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n}\n</code></pre>\n"}},{"text":"Merge","slug":"linked-list-merge","fullPath":"/learn/problems/linked-list/linked-list-merge","content":{"title":"Merge two sorted linked lists","slug":"linked-list-merge","contents":"<h3 id=\"solution-1\">Solution #1</h3>\n<p>Create a dummy node to keep track of start of merged list. Go through both and merge from small to large.</p>\n<h3 id=\"solution-2\">Solution #2</h3>\n<p>Don’t use a dummy and do an initialization step to keep track of return node.</p>\n<h3 id=\"complexity\">Complexity</h3>\n<p>Worst case is O(N) time (N = total nr of nodes) and best case O(1) (when first list has length 1 and second length N-1 - then we just “hang” them onto each other).</p>\n<p>Space is O(1).</p>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static Node merge(Node first, Node second) {\n        if (first == null) {\n            return second;\n        } else if (second == null) {\n            return first;\n        }\n\n        // Create dummy node to avoid initializing merged list.\n        Node dummy = new Node(0, 0);\n        Node merged = dummy;\n\n        // Take the smallest node from first/second while none is null.\n        while (first != null &amp;&amp; second != null) {\n            if (first.getValue() &lt; second.getValue()) {\n                merged.setNext(first);\n                first = first.getNext();\n            } else {\n                merged.setNext(second);\n                second = second.getNext();\n        }\n\n            merged = merged.getNext();\n        }\n\n        // Merge the left over nodes.\n        Node  leftOver = first == null ? second : first;\n        merged.setNext(leftOver);\n\n        return dummy.getNext();\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static Node merge(Node first, Node second) {\n        if (first == null) {\n            return second;\n        } else if (second == null) {\n            return first;\n        }\n\n        Node merged;\n        Node mergedStart;\n\n        // Initialize the merged list.\n        if (first.getValue() &lt; second.getValue()) {\n            merged = first;\n            first = first.getNext();\n        } else {\n            merged = second;\n            second = second.getNext();\n        }\n\n        mergedStart = merged;\n\n        // Take the smallest node from first/second while none is null.\n        while (first != null &amp;&amp; second != null) {\n            if (first.getValue() &lt; second.getValue()) {\n                merged.setNext(first);\n                first = first.getNext();\n            } else {\n                merged.setNext(second);\n                second = second.getNext();\n            }\n\n            merged = merged.getNext();\n        }\n\n        // Merge the left over nodes.\n        Node  leftOver = first == null ? second : first;\n        merged.setNext(leftOver);\n\n        return mergedStart;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Node {\n\n    private final int id;\n    private Node next;\n    private int value;\n\n    public Node(int id, int value) {\n        this.id = id;\n        this.value = value;\n    }\n\n    public Node getNext() {\n        return next;\n    }\n\n    public void setNext(Node next) {\n        this.next = next;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n}\n</code></pre>\n"}}],"fullPath":"/learn/problems/linked-list"},{"route":"strings","text":"Strings","children":[{"text":"Anagram","slug":"strings-anagram","fullPath":"/learn/problems/strings/strings-anagram","content":{"title":"Anagram","slug":"strings-anagram","contents":"<h3 id=\"description\">Description</h3>\n<p>Write a function to determine if one String is an anagram of another (anagram = shuffled chars).</p>\n<h3 id=\"solution-1\">Solution #1</h3>\n<p>Use some sort (quicksort, mergesort etc.) and compare.</p>\n<p>Complexity –&gt; O(2 * N log N + N) =  O(N log N)  time and O(1) space.</p>\n<h3 id=\"solution-2\">Solution #2</h3>\n<p>Compare both Strings against an array of found chars. Must assume a low number of chars (like ASCII), otherwise too much space usage.</p>\n<p>Complexity –&gt; O(2N) = O(N) time and O(1) space.</p>\n<h3 id=\"solution\">Solution</h3>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean isAnagram(char[] first, char[] second) {\n        if (first.length != second.length || first.length == 0) {\n            return false;\n        }\n\n        // O(2 * N log N).\n        Arrays.sort(first);\n        Arrays.sort(second);\n\n        // O(N).\n        for (int i = 0; i &lt; first.length; i++) {\n            if (first[i] != second[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean isAnagram(char[] first, char[] second) {\n        if (first.length != second.length || first.length == 0) {\n            return false;\n        }\n\n        int[] charCounts = new int[256];\n        int nrOfUniqueChars = 0;\n        int completedChars = 0;\n\n        // Go through first array --&gt; O(N).\n        for (int i = 0; i &lt; first.length; i++) {\n            if (charCounts[first[i]] == 0) {\n                nrOfUniqueChars++;\n            }\n\n            charCounts[first[i]]++;\n        }\n\n        // Check second against first array --&gt; O(N).\n        for (int i = 0; i &lt; second.length; i++) {\n\n            // Not an anagram if we find a char in second which isn&#39;t present in first.\n            if (charCounts[second[i]] == 0) {\n                return false;\n            }\n\n            // For every found char, the count is reduced.\n            charCounts[second[i]]--;\n\n            // We&#39;re done if all unique chars have been found.\n            if (charCounts[second[i]] == 0) {\n                completedChars++;\n                if (completedChars == nrOfUniqueChars) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n</code></pre>\n"}},{"text":"Palindrome","slug":"strings-palindrome","fullPath":"/learn/problems/strings/strings-palindrome","content":{"title":"Palindrome","slug":"strings-palindrome","contents":"<h3 id=\"description\">Description</h3>\n<p>Write a function to determine if one String is a palindrome (forward = backwards).</p>\n<h2 id=\"solution\">Solution</h2>\n<p>Two pointers - one goes forward and one backwards to the middle.</p>\n<pre><code class=\"lang-java\">public static boolean isPalindrome(String input) {\n    int rightIdx = input.length() - 1;\n\n    for (int leftIdx = 0; leftIdx &lt; input.length() / 2; leftIdx++) {\n        if (input.charAt(leftIdx) != input.charAt(rightIdx)) {\n            return false;\n        }\n        rightIdx--;\n    }\n\n    return true;\n}\n</code></pre>\n"}},{"text":"Unique chars","slug":"strings-unique-chars","fullPath":"/learn/problems/strings/strings-unique-chars","content":{"title":"Unique characters in a String","slug":"strings-unique-chars","contents":"<h3 id=\"description\">Description</h3>\n<p>Write a function to determine if a String has all unique characters.</p>\n<h3 id=\"solution-1\">Solution #1</h3>\n<p>Assume ASCII = 256 chars. Store in boolean array. Go through entire String.</p>\n<p>Complexity –&gt; O(N) time and O(1) space.</p>\n<h3 id=\"solution-2\">Solution #2</h3>\n<p>Assume only [a-z] = 26 chars. Store in an int (32 bits). Go through entire String.</p>\n<p>Complexity –&gt; O(N) time and O(1) space.</p>\n<h3 id=\"solution-3\">Solution #3</h3>\n<p>Assume any value of Java char = 16 bits –&gt; 2^16 different values. Store in a BitSet with 2^16 = 65536. Go through entire String.</p>\n<p>Complexity –&gt; O(N) time and O(1) space.</p>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean uniqueChars(String string) {\n        if (string.length() &gt; 256) {\n            return false;\n        }\n\n        boolean[] foundChars = new boolean[256];\n\n        for (char character : string.toCharArray()) {\n            if (foundChars[character]) {\n                return false;\n            }\n\n            foundChars[character] = true;\n        }\n\n        return true;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean uniqueChars(String string) {\n        if (string.length() &gt; 26) {\n            return false;\n        }\n\n        int foundChars = 0;\n\n        for (char character : string.toCharArray()) {\n            if ((foundChars &amp; (1 &lt;&lt; character)) &gt; 0) {\n                return false;\n            }\n\n            foundChars = foundChars | (1 &lt;&lt; character);\n        }\n\n        return true;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    public static boolean uniqueChars(String string) {\n        int assumedNrOfPossibleChars = 1 &lt;&lt; 16; // 2^16\n        if (string.length() &gt; assumedNrOfPossibleChars) {\n            return false;\n        }\n\n        BitSet charset = new BitSet(assumedNrOfPossibleChars);\n        for (char character : string.toCharArray()) {\n            if (charset.get(character)) {\n                return false;\n            }\n            charset.set(character);\n        }\n        return true;\n    }\n}\n</code></pre>\n"}}],"fullPath":"/learn/problems/strings"},{"route":"trees","text":"Trees","children":[{"text":"BST balanced","slug":"trees-bst-balanced","fullPath":"/learn/problems/trees/trees-bst-balanced","content":{"title":"Is the BST balanced?","slug":"trees-bst-balanced","contents":"<p>More information is coming!</p>\n"}}],"fullPath":"/learn/problems/trees"}],"fullPath":"/learn/problems"}}}
