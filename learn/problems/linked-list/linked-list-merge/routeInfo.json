{"path":"learn/problems/linked-list/linked-list-merge","templateID":3,"sharedPropsHashes":{},"localProps":{"node":{"text":"Merge","slug":"linked-list-merge","fullPath":"/learn/problems/linked-list/linked-list-merge","content":{"title":"Merge two sorted linked lists","slug":"linked-list-merge","contents":"<h3 id=\"solution-1\">Solution #1</h3>\n<p>Create a dummy node to keep track of start of merged list. Go through both and merge from small to large.</p>\n<h3 id=\"solution-2\">Solution #2</h3>\n<p>Don’t use a dummy and do an initialization step to keep track of return node.</p>\n<h3 id=\"complexity\">Complexity</h3>\n<p>Worst case is O(N) time (N = total nr of nodes) and best case O(1) (when first list has length 1 and second length N-1 - then we just “hang” them onto each other).</p>\n<p>Space is O(1).</p>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    public static Node merge(Node first, Node second) {\n        if (first == null) {\n            return second;\n        } else if (second == null) {\n            return first;\n        }\n\n        // Create dummy node to avoid initializing merged list.\n        Node dummy = new Node(0, 0);\n        Node merged = dummy;\n\n        // Take the smallest node from first/second while none is null.\n        while (first != null &amp;&amp; second != null) {\n            if (first.getValue() &lt; second.getValue()) {\n                merged.setNext(first);\n                first = first.getNext();\n            } else {\n                merged.setNext(second);\n                second = second.getNext();\n        }\n\n            merged = merged.getNext();\n        }\n\n        // Merge the left over nodes.\n        Node  leftOver = first == null ? second : first;\n        merged.setNext(leftOver);\n\n        return dummy.getNext();\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    public static Node merge(Node first, Node second) {\n        if (first == null) {\n            return second;\n        } else if (second == null) {\n            return first;\n        }\n\n        Node merged;\n        Node mergedStart;\n\n        // Initialize the merged list.\n        if (first.getValue() &lt; second.getValue()) {\n            merged = first;\n            first = first.getNext();\n        } else {\n            merged = second;\n            second = second.getNext();\n        }\n\n        mergedStart = merged;\n\n        // Take the smallest node from first/second while none is null.\n        while (first != null &amp;&amp; second != null) {\n            if (first.getValue() &lt; second.getValue()) {\n                merged.setNext(first);\n                first = first.getNext();\n            } else {\n                merged.setNext(second);\n                second = second.getNext();\n            }\n\n            merged = merged.getNext();\n        }\n\n        // Merge the left over nodes.\n        Node  leftOver = first == null ? second : first;\n        merged.setNext(leftOver);\n\n        return mergedStart;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Node {\n\n    private final int id;\n    private Node next;\n    private int value;\n\n    public Node(int id, int value) {\n        this.id = id;\n        this.value = value;\n    }\n\n    public Node getNext() {\n        return next;\n    }\n\n    public void setNext(Node next) {\n        this.next = next;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n}\n</code></pre>\n"}}}}
