<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><link rel="preload" as="script" href="https://codercatch.com/templates/styles.d2f9c1d1.js"/><link rel="preload" as="script" href="https://codercatch.com/templates/vendors~Users/Nina/git/code-yay/src/components/LearnNode.tsx~Users/Nina/git/code-yay/src/containers/Post.tsx.7be0efee.js"/><link rel="preload" as="script" href="https://codercatch.com/templates/Users/Nina/git/code-yay/src/components/LearnNode.tsx.1755bae2.js"/><link rel="preload" as="script" href="https://codercatch.com/templates/vendors~main.77f775ef.js"/><link rel="preload" as="script" href="https://codercatch.com/main.5556fce0.js"/><link rel="preload" as="style" href="https://codercatch.com/styles.d2f9c1d1.css"/><link rel="stylesheet" href="https://codercatch.com/styles.d2f9c1d1.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/></head><body><div id="root"><div style="outline:none" tabindex="-1" role="group"><div class="sc-EHOje gghtrN"><div class="sc-bZQynM bnbpXH"><div class="sc-bdVaJa UoSJW"><header class="MuiPaper-root MuiPaper-elevation4 MuiAppBar-root MuiAppBar-positionStatic MuiAppBar-colorPrimary"><div class="MuiToolbar-root MuiToolbar-regular MuiToolbar-gutters"><a href="https://codercatch.com/">coder â€¢ catch</a><div class="sc-bwzfXH fZWKdm"></div><div class="sc-bxivhb daznuY"><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/interview-prep">Interview prep</a></li><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/blog">Blog</a></li><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/about">About</a></li></div><div class="sc-htpNat dlQEJK"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit" tabindex="0" type="button" aria-haspopup="true"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span></button></div></div></header></div></div><div class="sc-gzVnrw jkZyAP"><div style="outline:none" tabindex="-1" role="group"><div><h1>Recursion</h1><div><h3>What?</h3><p>A function being defined is applied within its own definition. Or in other words, recursion is when a function calls itself.</p></div><div class="sc-htoDjs ecPgpk"><h3 id="good">Good</h3>
<p>Elegant, simple. Some languages are well suited for it. Instead of the call stack being a problem, you can
actually take advantage of it in a clever way by doing iterative branching --&gt; for example call a function
multiple times in same loop but with different parameters, that&#x27;s branching. If you try an iterative solution,
you often need a stack and you re-invent the wheel.</p>
<h3 id="bad">Bad</h3>
<p>In most languages it&#x27;s bad, because of Stack Overflow issues + it also takes some time to copy stuff to stack etc.
so it will run slower due to function call overhead.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li>Simple way: compute by reasoning about how many times function will be called.</li>
<li>More difficult cases: use Master Theorem or guess and use induction. Example: recursive fibonacci --&gt; T(n-1) + T(n-2) + T(1) --&gt; O(fib(n)) ~= O(1.6^n)</li>
</ul>
<h3 id="examples-of-time-complexity">Examples of Time Complexity</h3>
<pre><code class="language-java">
// O(N/3) = O(N)
int function1(int n) {
    if (n &lt;= 0) {
        return 1;
    } else {
        return 1 + recursiveFun1(n-3);
    }
}

// O(log4 N) = O(log N)
int function2(int n) {
    if (n &lt;= 0) {
        return 1;
    } else {
        return 1 + function2(n/4);
    }
}

// O(2^N) --&gt; Think of this as a binary tree with height N.
int function3(int n) {
    if (n &lt;= 0) {
        return 1;
    } else {
        function3(n - 1);
        function3(n - 1);
    }
}

// ???
int function4(int n) {
    for (i = 0; i &lt; n; i += 2) {
        System.out.println(&quot;Hello&quot;);
    }

    if (n &lt;= 0) {
        return 1;
    } else {
        return 1 + function4(n-5);
    }
}</code></pre></div></div></div></div></div></div></div><script type="text/javascript">
    window.__routeInfo = JSON.parse("{\"template\":\"/Users/Nina/git/code-yay/src/components/LearnNode.tsx\",\"sharedHashesByProp\":{},\"data\":{\"node\":{\"text\":\"Recursion\",\"slug\":\"recursion\",\"fullPath\":\"/learn/concepts/recursion\",\"content\":{\"title\":\"Recursion\",\"slug\":\"recursion\",\"what\":\"A function being defined is applied within its own definition. Or in other words, recursion is when a function calls itself.\",\"contents\":\"<h3 id=\\\"good\\\">Good</h3>\\n<p>Elegant, simple. Some languages are well suited for it. Instead of the call stack being a problem, you can\\nactually take advantage of it in a clever way by doing iterative branching --&gt; for example call a function\\nmultiple times in same loop but with different parameters, that&#39;s branching. If you try an iterative solution,\\nyou often need a stack and you re-invent the wheel.</p>\\n<h3 id=\\\"bad\\\">Bad</h3>\\n<p>In most languages it&#39;s bad, because of Stack Overflow issues + it also takes some time to copy stuff to stack etc.\\nso it will run slower due to function call overhead.</p>\\n<h3 id=\\\"time-complexity\\\">Time Complexity</h3>\\n<ul>\\n<li>Simple way: compute by reasoning about how many times function will be called.</li>\\n<li>More difficult cases: use Master Theorem or guess and use induction. Example: recursive fibonacci --&gt; T(n-1) + T(n-2) + T(1) --&gt; O(fib(n)) ~= O(1.6^n)</li>\\n</ul>\\n<h3 id=\\\"examples-of-time-complexity\\\">Examples of Time Complexity</h3>\\n<pre><code class=\\\"language-java\\\">\\n// O(N/3) = O(N)\\nint function1(int n) {\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        return 1 + recursiveFun1(n-3);\\n    }\\n}\\n\\n// O(log4 N) = O(log N)\\nint function2(int n) {\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        return 1 + function2(n/4);\\n    }\\n}\\n\\n// O(2^N) --&gt; Think of this as a binary tree with height N.\\nint function3(int n) {\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        function3(n - 1);\\n        function3(n - 1);\\n    }\\n}\\n\\n// ???\\nint function4(int n) {\\n    for (i = 0; i &lt; n; i += 2) {\\n        System.out.println(&quot;Hello&quot;);\\n    }\\n\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        return 1 + function4(n-5);\\n    }\\n}</code></pre>\\n\"}}},\"path\":\"learn/concepts/recursion\",\"sharedData\":{},\"siteData\":{\"title\":\"code-yay\"}}");</script><script defer="" type="text/javascript" src="https://codercatch.com/templates/styles.d2f9c1d1.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/templates/vendors~Users/Nina/git/code-yay/src/components/LearnNode.tsx~Users/Nina/git/code-yay/src/containers/Post.tsx.7be0efee.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/templates/Users/Nina/git/code-yay/src/components/LearnNode.tsx.1755bae2.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/templates/vendors~main.77f775ef.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/main.5556fce0.js"></script></body></html>