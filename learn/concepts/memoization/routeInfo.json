{"path":"learn/concepts/memoization","templateID":2,"sharedPropsHashes":{},"localProps":{"node":{"text":"Memoization","slug":"memoization","fullPath":"/learn/concepts/memoization","content":{"title":"Memoization","slug":"memoization","what":"DP --> Solve problems recursively when computations of subproblems overlap. Memoization --> Memorizing sub problems to avoid recomputing them.","contents":"<h3 id=\"example-calculate-n-th-fibonacci-number\">Example: calculate n’th fibonacci number</h3>\n<p>To calculate fibonacci(n) we need fibonacci(n-1) + fibonacci(n-2) –&gt; leads to a lot of unnecessary recomputing.\nWe must use memoization! If we try to compute the 50th fibonacci nr with the slow and the fast one, we see a\nhuge difference in running time.</p>\n<pre><code class=\"lang-java\">public class Codeyay {\n    public static int fibonacci(int n) {\n        return n &lt; 2 ? n : fibonacci(n-1) + fibonacci(n-2);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    private static Map&amp;lt;Integer, Long&amp;gt; cache = new HashMap&lt;&gt;();\n\n    public static long fibonacci(int n) {\n        if (n &lt; 2) {\n            return n;\n        }\n\n        Long value = cache.get(n);\n\n        if (value == null) {\n            value = fibonacci(n-1) + fibonacci(n-2);\n            cache.put(n, value);\n        }\n\n        return value;\n    }\n}\n</code></pre>\n"}}}}
