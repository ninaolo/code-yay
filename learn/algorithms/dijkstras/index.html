<!DOCTYPE html><html lang="en"><head><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/bootstrap.85a21347.js"/><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/templates/src/components/LearnNode.43e060e6.js"/><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/main.73dea303.js"/><link rel="preload" as="style" href="https://ninaolo.github.io/code-yay/styles.279679c8.css"/><link rel="stylesheet" href="https://ninaolo.github.io/code-yay/styles.279679c8.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><style data-styled-components="biWukS qixWb iVLXoD kLmEQe geGfki kpBMbA huPxDo dlogSQ">
/* sc-component-id: Navbar__StyledNavbar-bn5y01-0 */
.iVLXoD{width:100%;}
/* sc-component-id: Navbar__MiddleSpace-bn5y01-1 */
.kLmEQe{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}
/* sc-component-id: Navbar__MobileSection-bn5y01-2 */
.kpBMbA{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;} @media (min-width:960px){.kpBMbA{display:none;}}
/* sc-component-id: Navbar__DesktopSection-bn5y01-3 */
.geGfki{display:none;} @media (min-width:960px){.geGfki{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}
/* sc-component-id: sc-global-1865284974 */
body{font-family:Lato;font-weight:400;-webkit-letter-spacing:0.3px;-moz-letter-spacing:0.3px;-ms-letter-spacing:0.3px;letter-spacing:0.3px;line-height:1.5;font-size:15px;margin:0;padding:0;color:#4e4e4e;}
/* sc-component-id: App__AppStyles-nie0ws-0 */
.biWukS a{-webkit-text-decoration:none;text-decoration:none;color:#704f56;font-weight:bold;} .biWukS img{max-width:100%;} .biWukS h1,.biWukS h2,.biWukS h3,.biWukS h4,.biWukS h5{color:#1e1e1e;}
/* sc-component-id: App__StyledNavbar-nie0ws-1 */
.qixWb a,.qixWb span{color:white;font-family:Lato;}
/* sc-component-id: App__MainContent-nie0ws-2 */
.huPxDo{padding:3% 5%;}
/* sc-component-id: MarkdownContent__StyledMarkdownContent-sc-1cke1eq-0 */
.dlogSQ.dlogSQ pre{background:#f4f4f4;font-size:13px;padding:.8em;overflow:auto;border-radius:7px;}</style></head><body><div id="root"><div class="App__AppStyles-nie0ws-0 biWukS" data-reactroot=""><div class="App__StyledNavbar-nie0ws-1 qixWb"><div class="Navbar__StyledNavbar-bn5y01-0 iVLXoD"><header class="jss10 jss16 jss1 jss5 jss8"><div class="jss37 jss39 jss38"><h2 class="jss41 jss47 jss61 jss58"><a href="https://ninaolo.github.io/code-yay/interview-prep">code • yay</a></h2><div class="Navbar__MiddleSpace-bn5y01-1 kLmEQe"></div><div class="Navbar__DesktopSection-bn5y01-3 geGfki"><li tabindex="-1" class="jss80 jss69 jss72 jss76 jss77 jss67" role="menuitem"><a href="https://ninaolo.github.io/code-yay/blog">Blog</a><span class="jss83"></span></li><li tabindex="-1" class="jss80 jss69 jss72 jss76 jss77 jss67" role="menuitem"><a href="https://ninaolo.github.io/code-yay/about">About</a><span class="jss83"></span></li></div><div class="Navbar__MobileSection-bn5y01-2 kpBMbA"><button tabindex="0" class="jss80 jss90 jss91" type="button" aria-haspopup="true"><span class="jss95"><svg class="jss96" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path fill="none" d="M0 0h24v24H0z"></path><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span><span class="jss83"></span></button></div></div></header></div></div><div class="App__MainContent-nie0ws-2 huPxDo"><div><h1>Dijkstra&#x27;s algorithm</h1><div><h3>What?</h3><p>Finds the shortest path to all vertices in a Directed Weighted Graph (easily modified for undirected) given a start vertex.</p></div><div><h3>How?</h3><ul><li>Given a start vertex.</li><li>Put start vertex in queue (min-heap).</li><li>While queue is not empty...</li><li>Poll the queue for the current vertex.</li><li>Go through its adjacency list (list of edges).</li><li>For all edges, find neighbors and evaluate cost to get there from current.</li><li>If lower than current min, update min-heap with the new values.</li></ul></div><div class="MarkdownContent__StyledMarkdownContent-sc-1cke1eq-0 dlogSQ"><h3 id="constraints">Constraints</h3>
<p>Original/simple version doesn’t work with negative weights (but the below does). However, it doesn’t work if we have cycles with negative sum (will loop forever). The Bellman–Ford algorithm can be used in such cases.</p>
<h3 id="some-information">Some information</h3>
<p>Original algorithm doesn’t use a min-priority queue –&gt; O(V^2). A min-priority queue is an optimization (even faster if it’s a Fibonacci heap).</p>
<p>This is asymptotically the fastest known single-source shortest-path algorithm for directed graphs with unbounded, non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can be improved further.</p>
<h3 id="different-implementations">Different implementations</h3>
<p>There are different ways to represent a graph.</p>
<ul>
<li>Adjacency Matrix is preferable when we expect the graph to be dense.</li>
<li>Adjacency List is preferable when we expect the graph to be sparse.</li>
</ul>
<h3 id="implementation">Implementation</h3>
<pre><code class="lang-java">public class Codeyay {

    /**
     * Update the min-distances and predecessors on all vertices given a certain source vertex.
     */
    public static void updateDijkstraDistances(Vertex source) {
        source.setMinDistance(0);
        PriorityQueue&amp;lt;Vertex&amp;gt; vertexQueue = new PriorityQueue&lt;&gt;();
        vertexQueue.add(source);

        while (!vertexQueue.isEmpty()) {

            // Get and remove the current prioritized vertex &amp; visit all of its edges.
            Vertex current = vertexQueue.poll();

            for (Edge edge : current.getEdges()) {
                Vertex neighbor = edge.getDestination();
                double distanceToNeighbor = current.getMinDistance() + edge.getCost();

                // If we found a new min distance to the neighbor, update it. Note: remove
                // is O(V) and add is O(log V) so the optimized Dijkstra should use a
                // decreaseKey-operation with O(log V) time, but I&#x27;m using this for simplicity.
                if (distanceToNeighbor &lt; neighbor.getMinDistance()) {
                    vertexQueue.remove(neighbor);
                    neighbor.setMinDistance(distanceToNeighbor);
                    neighbor.setPredecessor(current);
                    vertexQueue.add(neighbor);
                }
            }
        }
    }
}
</code></pre>
<pre><code class="lang-java">
public class Graph {

    private Vertex[] vertices;

    public Graph(Vertex[] vertices) {
        this.vertices = vertices;
    }

    public Vertex[] getVertices() {
        return vertices;
    }
}
</code></pre>
<pre><code class="lang-java">public class Vertex {

    // Properties representing the vertex itself.
    private int id;
    private Edge[] adjacencyList;

    // Properties updated by the Dijkstra algorithm depending on a given source vertex.
    private double minDistance = Double.POSITIVE_INFINITY;
    private Vertex predecessor;

    public Vertex(int id) {
        this.id = id;
    }

    // This is needed in order to put this object in a priority queue.
    public int compareTo(Vertex other) {
        Double.compare(minDistance, other.minDistance);
    }

    public int getId() {
        return id;
    }

    public Edge[] getEdges() {
        return adjacencyList == null ? new Edge[0] : adjacencyList;
    }

    public void setEdges(Edge[] adjacencyList) {
        this.adjacencyList = adjacencyList;
    }

    public double getMinDistance() {
        return minDistance;
    }

    public Vertex getPredecessor() {
        return predecessor;
    }

    public void setMinDistance(double minDistance) {
        this.minDistance = minDistance;
    }

    public void setPredecessor(Vertex predecessor) {
        this.predecessor = predecessor;
    }
}
</code></pre>
<pre><code class="lang-java">public class Edge {

    private Vertex destination;
    private double weight;

    public Edge(Vertex destination, double weight) {
        this.destination = destination;
        this.weight = weight;
    }

    public Vertex getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }
}
</code></pre></div></div></div></div></div><script type="text/javascript">window.__CSS_CHUNKS__ = {"main":"https://ninaolo.github.io/code-yay/styles.279679c8.css"}</script><script type="text/javascript">
    window.__routeInfo = {"path":"learn/algorithms/dijkstras","templateID":3,"sharedPropsHashes":{},"localProps":null,"allProps":{"node":{"text":"Dijkstras","slug":"dijkstras","fullPath":"/learn/algorithms/dijkstras","content":{"title":"Dijkstra's algorithm","slug":"dijkstras","what":"Finds the shortest path to all vertices in a Directed Weighted Graph (easily modified for undirected) given a start vertex.","how":"Given a start vertex. | Put start vertex in queue (min-heap). | While queue is not empty... | Poll the queue for the current vertex. | Go through its adjacency list (list of edges). | For all edges, find neighbors and evaluate cost to get there from current. | If lower than current min, update min-heap with the new values.","averageTime":"O(E log V) with a binary heap, because we go through all vertices and do poll() --> O(V log V). In the inner loop we go though all edges and possibly do a decreaseKey-operation --> O(E log V). Final complexity is O(V log V) + O(E log V) = O(E log V). With a fibonacci heap it's O(E + V log V).","space":"Adjacency list --> O(V + E). Adjacency matrix --> O(V^2).","contents":"<h3 id=\"constraints\">Constraints</h3>\n<p>Original/simple version doesn’t work with negative weights (but the below does). However, it doesn’t work if we have cycles with negative sum (will loop forever). The Bellman–Ford algorithm can be used in such cases.</p>\n<h3 id=\"some-information\">Some information</h3>\n<p>Original algorithm doesn’t use a min-priority queue –&gt; O(V^2). A min-priority queue is an optimization (even faster if it’s a Fibonacci heap).</p>\n<p>This is asymptotically the fastest known single-source shortest-path algorithm for directed graphs with unbounded, non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can be improved further.</p>\n<h3 id=\"different-implementations\">Different implementations</h3>\n<p>There are different ways to represent a graph.</p>\n<ul>\n<li>Adjacency Matrix is preferable when we expect the graph to be dense.</li>\n<li>Adjacency List is preferable when we expect the graph to be sparse.</li>\n</ul>\n<h3 id=\"implementation\">Implementation</h3>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    /**\n     * Update the min-distances and predecessors on all vertices given a certain source vertex.\n     */\n    public static void updateDijkstraDistances(Vertex source) {\n        source.setMinDistance(0);\n        PriorityQueue&amp;lt;Vertex&amp;gt; vertexQueue = new PriorityQueue&lt;&gt;();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n\n            // Get and remove the current prioritized vertex &amp; visit all of its edges.\n            Vertex current = vertexQueue.poll();\n\n            for (Edge edge : current.getEdges()) {\n                Vertex neighbor = edge.getDestination();\n                double distanceToNeighbor = current.getMinDistance() + edge.getCost();\n\n                // If we found a new min distance to the neighbor, update it. Note: remove\n                // is O(V) and add is O(log V) so the optimized Dijkstra should use a\n                // decreaseKey-operation with O(log V) time, but I&#39;m using this for simplicity.\n                if (distanceToNeighbor &lt; neighbor.getMinDistance()) {\n                    vertexQueue.remove(neighbor);\n                    neighbor.setMinDistance(distanceToNeighbor);\n                    neighbor.setPredecessor(current);\n                    vertexQueue.add(neighbor);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">\npublic class Graph {\n\n    private Vertex[] vertices;\n\n    public Graph(Vertex[] vertices) {\n        this.vertices = vertices;\n    }\n\n    public Vertex[] getVertices() {\n        return vertices;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Vertex {\n\n    // Properties representing the vertex itself.\n    private int id;\n    private Edge[] adjacencyList;\n\n    // Properties updated by the Dijkstra algorithm depending on a given source vertex.\n    private double minDistance = Double.POSITIVE_INFINITY;\n    private Vertex predecessor;\n\n    public Vertex(int id) {\n        this.id = id;\n    }\n\n    // This is needed in order to put this object in a priority queue.\n    public int compareTo(Vertex other) {\n        Double.compare(minDistance, other.minDistance);\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Edge[] getEdges() {\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\n    }\n\n    public void setEdges(Edge[] adjacencyList) {\n        this.adjacencyList = adjacencyList;\n    }\n\n    public double getMinDistance() {\n        return minDistance;\n    }\n\n    public Vertex getPredecessor() {\n        return predecessor;\n    }\n\n    public void setMinDistance(double minDistance) {\n        this.minDistance = minDistance;\n    }\n\n    public void setPredecessor(Vertex predecessor) {\n        this.predecessor = predecessor;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Edge {\n\n    private Vertex destination;\n    private double weight;\n\n    public Edge(Vertex destination, double weight) {\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    public Vertex getDestination() {\n        return destination;\n    }\n\n    public double getWeight() {\n        return weight;\n    }\n}\n</code></pre>\n"}}},"siteData":{"title":"code-yay"}};</script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/bootstrap.85a21347.js"></script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/templates/src/components/LearnNode.43e060e6.js"></script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/main.73dea303.js"></script></body></html>