<!DOCTYPE html><html lang="en"><head><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/bootstrap.f38e3ba8.js"/><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/templates/src/components/LearnNode.74ffed10.js"/><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/main.d908907e.js"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><style data-styled-components="fTcnXq fMtres huPxDo">
/* sc-component-id: sc-global-3667178187 */
body{font-family:'HelveticaNeue-Light','Helvetica Neue Light','Helvetica Neue',Helvetica,Arial, 'Lucida Grande',sans-serif;font-weight:300;font-size:15px;margin:0;padding:0;}
/* sc-component-id: App__AppStyles-nie0ws-0 */
.fTcnXq a{-webkit-text-decoration:none;text-decoration:none;color:#704f56;font-weight:bold;} .fTcnXq img{max-width:100%;} .fTcnXq pre{background:#f4f4f4;padding:.8em;overflow:auto;border-radius:7px;margin:35px 0;}
/* sc-component-id: App__Navbar-nie0ws-1 */
.fMtres{width:100%;background:#39ae7f;} .fMtres a,.fMtres span{color:white;padding:1rem;display:inline-block;}
/* sc-component-id: App__MainContent-nie0ws-2 */
.huPxDo{padding:3% 5%;}</style></head><body><div id="root"><div class="App__AppStyles-nie0ws-0 fTcnXq" data-reactroot=""><nav class="App__Navbar-nie0ws-1 fMtres"><a href="https://ninaolo.github.io/code-yay/">code • yay</a><span>|</span><a href="https://ninaolo.github.io/code-yay/about">About</a><a href="https://ninaolo.github.io/code-yay/blog">Blog</a><a class="active" aria-current="page" href="https://ninaolo.github.io/code-yay/learn">Learn</a></nav><div class="App__MainContent-nie0ws-2 huPxDo"><div><h1>Dijkstra&#x27;s algorithm</h1><div><h3>What?</h3><p>Finds the shortest path to all vertices in a Directed Weighted Graph (easily modified for undirected) given a start vertex.</p></div><div><h3>How?</h3><ul><li>Given a start vertex.</li><li>Put start vertex in queue (min-heap).</li><li>While queue is not empty...</li><li>Poll the queue for the current vertex.</li><li>Go through its adjacency list (list of edges).</li><li>For all edges, find neighbors and evaluate cost to get there from current.</li><li>If lower than current min, update min-heap with the new values.</li></ul></div><div><h3 id="constraints">Constraints</h3>
<p>Original/simple version doesn’t work with negative weights (but the below does). However, it doesn’t work if we have cycles with negative sum (will loop forever). The Bellman–Ford algorithm can be used in such cases.</p>
<h3 id="some-information">Some information</h3>
<p>Original algorithm doesn’t use a min-priority queue –&gt; O(V^2). A min-priority queue is an optimization (even faster if it’s a Fibonacci heap).</p>
<p>This is asymptotically the fastest known single-source shortest-path algorithm for directed graphs with unbounded, non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can be improved further.</p>
<h3 id="different-implementations">Different implementations</h3>
<p>There are different ways to represent a graph.</p>
<ul>
<li>Adjacency Matrix is preferable when we expect the graph to be dense.</li>
<li>Adjacency List is preferable when we expect the graph to be sparse.</li>
</ul>
<h3 id="implementation">Implementation</h3>
<pre><code class="lang-java">public class Coderview {

    /**
     * Update the min-distances and predecessors on all vertices given a certain source vertex.
     */
    public static void updateDijkstraDistances(Vertex source) {
        source.setMinDistance(0);
        PriorityQueue&amp;lt;Vertex&amp;gt; vertexQueue = new PriorityQueue&lt;&gt;();
        vertexQueue.add(source);

        while (!vertexQueue.isEmpty()) {

            // Get and remove the current prioritized vertex &amp; visit all of its edges.
            Vertex current = vertexQueue.poll();

            for (Edge edge : current.getEdges()) {
                Vertex neighbor = edge.getDestination();
                double distanceToNeighbor = current.getMinDistance() + edge.getCost();

                // If we found a new min distance to the neighbor, update it. Note: remove
                // is O(V) and add is O(log V) so the optimized Dijkstra should use a
                // decreaseKey-operation with O(log V) time, but I&#x27;m using this for simplicity.
                if (distanceToNeighbor &lt; neighbor.getMinDistance()) {
                    vertexQueue.remove(neighbor);
                    neighbor.setMinDistance(distanceToNeighbor);
                    neighbor.setPredecessor(current);
                    vertexQueue.add(neighbor);
                }
            }
        }
    }
}
</code></pre>
<pre><code class="lang-java">
public class Graph {

    private Vertex[] vertices;

    public Graph(Vertex[] vertices) {
        this.vertices = vertices;
    }

    public Vertex[] getVertices() {
        return vertices;
    }
}
</code></pre>
<pre><code class="lang-java">public class Vertex {

    // Properties representing the vertex itself.
    private int id;
    private Edge[] adjacencyList;

    // Properties updated by the Dijkstra algorithm depending on a given source vertex.
    private double minDistance = Double.POSITIVE_INFINITY;
    private Vertex predecessor;

    public Vertex(int id) {
        this.id = id;
    }

    // This is needed in order to put this object in a priority queue.
    public int compareTo(Vertex other) {
        Double.compare(minDistance, other.minDistance);
    }

    public int getId() {
        return id;
    }

    public Edge[] getEdges() {
        return adjacencyList == null ? new Edge[0] : adjacencyList;
    }

    public void setEdges(Edge[] adjacencyList) {
        this.adjacencyList = adjacencyList;
    }

    public double getMinDistance() {
        return minDistance;
    }

    public Vertex getPredecessor() {
        return predecessor;
    }

    public void setMinDistance(double minDistance) {
        this.minDistance = minDistance;
    }

    public void setPredecessor(Vertex predecessor) {
        this.predecessor = predecessor;
    }
}
</code></pre>
<pre><code class="lang-java">public class Edge {

    private Vertex destination;
    private double weight;

    public Edge(Vertex destination, double weight) {
        this.destination = destination;
        this.weight = weight;
    }

    public Vertex getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }
}
</code></pre></div></div></div></div></div><script type="text/javascript">window.__CSS_CHUNKS__ = {}</script><script type="text/javascript">
    window.__routeInfo = {"path":"learn/algorithms/dijkstras","templateID":3,"sharedPropsHashes":{},"localProps":null,"allProps":{"node":{"text":"Dijkstras","slug":"dijkstras","fullPath":"/learn/algorithms/dijkstras","content":{"title":"Dijkstra's algorithm","slug":"dijkstras","what":"Finds the shortest path to all vertices in a Directed Weighted Graph (easily modified for undirected) given a start vertex.","how":"Given a start vertex. | Put start vertex in queue (min-heap). | While queue is not empty... | Poll the queue for the current vertex. | Go through its adjacency list (list of edges). | For all edges, find neighbors and evaluate cost to get there from current. | If lower than current min, update min-heap with the new values.","averageTime":"O(E log V) with a binary heap, because we go through all vertices and do poll() --> O(V log V). In the inner loop we go though all edges and possibly do a decreaseKey-operation --> O(E log V). Final complexity is O(V log V) + O(E log V) = O(E log V). With a fibonacci heap it's O(E + V log V).","space":"Adjacency list --> O(V + E). Adjacency matrix --> O(V^2).","contents":"<h3 id=\"constraints\">Constraints</h3>\n<p>Original/simple version doesn’t work with negative weights (but the below does). However, it doesn’t work if we have cycles with negative sum (will loop forever). The Bellman–Ford algorithm can be used in such cases.</p>\n<h3 id=\"some-information\">Some information</h3>\n<p>Original algorithm doesn’t use a min-priority queue –&gt; O(V^2). A min-priority queue is an optimization (even faster if it’s a Fibonacci heap).</p>\n<p>This is asymptotically the fastest known single-source shortest-path algorithm for directed graphs with unbounded, non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can be improved further.</p>\n<h3 id=\"different-implementations\">Different implementations</h3>\n<p>There are different ways to represent a graph.</p>\n<ul>\n<li>Adjacency Matrix is preferable when we expect the graph to be dense.</li>\n<li>Adjacency List is preferable when we expect the graph to be sparse.</li>\n</ul>\n<h3 id=\"implementation\">Implementation</h3>\n<pre><code class=\"lang-java\">public class Coderview {\n\n    /**\n     * Update the min-distances and predecessors on all vertices given a certain source vertex.\n     */\n    public static void updateDijkstraDistances(Vertex source) {\n        source.setMinDistance(0);\n        PriorityQueue&amp;lt;Vertex&amp;gt; vertexQueue = new PriorityQueue&lt;&gt;();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n\n            // Get and remove the current prioritized vertex &amp; visit all of its edges.\n            Vertex current = vertexQueue.poll();\n\n            for (Edge edge : current.getEdges()) {\n                Vertex neighbor = edge.getDestination();\n                double distanceToNeighbor = current.getMinDistance() + edge.getCost();\n\n                // If we found a new min distance to the neighbor, update it. Note: remove\n                // is O(V) and add is O(log V) so the optimized Dijkstra should use a\n                // decreaseKey-operation with O(log V) time, but I&#39;m using this for simplicity.\n                if (distanceToNeighbor &lt; neighbor.getMinDistance()) {\n                    vertexQueue.remove(neighbor);\n                    neighbor.setMinDistance(distanceToNeighbor);\n                    neighbor.setPredecessor(current);\n                    vertexQueue.add(neighbor);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">\npublic class Graph {\n\n    private Vertex[] vertices;\n\n    public Graph(Vertex[] vertices) {\n        this.vertices = vertices;\n    }\n\n    public Vertex[] getVertices() {\n        return vertices;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Vertex {\n\n    // Properties representing the vertex itself.\n    private int id;\n    private Edge[] adjacencyList;\n\n    // Properties updated by the Dijkstra algorithm depending on a given source vertex.\n    private double minDistance = Double.POSITIVE_INFINITY;\n    private Vertex predecessor;\n\n    public Vertex(int id) {\n        this.id = id;\n    }\n\n    // This is needed in order to put this object in a priority queue.\n    public int compareTo(Vertex other) {\n        Double.compare(minDistance, other.minDistance);\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Edge[] getEdges() {\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\n    }\n\n    public void setEdges(Edge[] adjacencyList) {\n        this.adjacencyList = adjacencyList;\n    }\n\n    public double getMinDistance() {\n        return minDistance;\n    }\n\n    public Vertex getPredecessor() {\n        return predecessor;\n    }\n\n    public void setMinDistance(double minDistance) {\n        this.minDistance = minDistance;\n    }\n\n    public void setPredecessor(Vertex predecessor) {\n        this.predecessor = predecessor;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Edge {\n\n    private Vertex destination;\n    private double weight;\n\n    public Edge(Vertex destination, double weight) {\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    public Vertex getDestination() {\n        return destination;\n    }\n\n    public double getWeight() {\n        return weight;\n    }\n}\n</code></pre>\n"}}},"siteData":{"title":"code-yay"}};</script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/bootstrap.f38e3ba8.js"></script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/templates/src/components/LearnNode.74ffed10.js"></script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/main.d908907e.js"></script></body></html>