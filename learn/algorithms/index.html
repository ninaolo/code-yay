<!DOCTYPE html><html lang="en"><head><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/bootstrap.85a21347.js"/><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/templates/src/containers/Learn.7222bb7b.js"/><link rel="preload" as="script" href="https://ninaolo.github.io/code-yay/main.73dea303.js"/><link rel="preload" as="style" href="https://ninaolo.github.io/code-yay/styles.279679c8.css"/><link rel="stylesheet" href="https://ninaolo.github.io/code-yay/styles.279679c8.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><style data-styled-components="biWukS qixWb iVLXoD kLmEQe geGfki kpBMbA huPxDo lnLSqJ eGrpnG bjcAIm">
/* sc-component-id: Navbar__StyledNavbar-bn5y01-0 */
.iVLXoD{width:100%;}
/* sc-component-id: Navbar__MiddleSpace-bn5y01-1 */
.kLmEQe{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}
/* sc-component-id: Navbar__MobileSection-bn5y01-2 */
.kpBMbA{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;} @media (min-width:960px){.kpBMbA{display:none;}}
/* sc-component-id: Navbar__DesktopSection-bn5y01-3 */
.geGfki{display:none;} @media (min-width:960px){.geGfki{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}
/* sc-component-id: Button__StyledButton-sc-1g3in10-0 */
.bjcAIm.bjcAIm{border-radius:1.5rem;padding:3rem;width:200px;text-transform:none;box-shadow:none;color:white;font-family:Lato;font-size:15px;}
/* sc-component-id: sc-global-1865284974 */
body{font-family:Lato;font-weight:400;-webkit-letter-spacing:0.3px;-moz-letter-spacing:0.3px;-ms-letter-spacing:0.3px;letter-spacing:0.3px;line-height:1.5;font-size:15px;margin:0;padding:0;color:#4e4e4e;}
/* sc-component-id: App__AppStyles-nie0ws-0 */
.biWukS a{-webkit-text-decoration:none;text-decoration:none;color:#704f56;font-weight:bold;} .biWukS img{max-width:100%;} .biWukS h1,.biWukS h2,.biWukS h3,.biWukS h4,.biWukS h5{color:#1e1e1e;}
/* sc-component-id: App__StyledNavbar-nie0ws-1 */
.qixWb a,.qixWb span{color:white;font-family:Lato;}
/* sc-component-id: App__MainContent-nie0ws-2 */
.huPxDo{padding:3% 5%;}
/* sc-component-id: LinkButtonList__StyledButtonContainer-jdwpw0-0 */
.eGrpnG{margin:1em 0;}
/* sc-component-id: LinkButtonList__StyledLearnButtons-jdwpw0-1 */
.lnLSqJ{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-evenly;-webkit-justify-content:space-evenly;-ms-flex-pack:space-evenly;justify-content:space-evenly;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-align-content:space-evenly;-ms-flex-line-pack:space-evenly;align-content:space-evenly;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style></head><body><div id="root"><div class="App__AppStyles-nie0ws-0 biWukS" data-reactroot=""><div class="App__StyledNavbar-nie0ws-1 qixWb"><div class="Navbar__StyledNavbar-bn5y01-0 iVLXoD"><header class="jss10 jss16 jss1 jss5 jss8"><div class="jss37 jss39 jss38"><h2 class="jss41 jss47 jss61 jss58"><a href="https://ninaolo.github.io/code-yay/interview-prep">code • yay</a></h2><div class="Navbar__MiddleSpace-bn5y01-1 kLmEQe"></div><div class="Navbar__DesktopSection-bn5y01-3 geGfki"><li tabindex="-1" class="jss80 jss69 jss72 jss76 jss77 jss67" role="menuitem"><a href="https://ninaolo.github.io/code-yay/blog">Blog</a><span class="jss83"></span></li><li tabindex="-1" class="jss80 jss69 jss72 jss76 jss77 jss67" role="menuitem"><a href="https://ninaolo.github.io/code-yay/about">About</a><span class="jss83"></span></li></div><div class="Navbar__MobileSection-bn5y01-2 kpBMbA"><button tabindex="0" class="jss80 jss90 jss91" type="button" aria-haspopup="true"><span class="jss95"><svg class="jss96" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path fill="none" d="M0 0h24v24H0z"></path><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span><span class="jss83"></span></button></div></div></header></div></div><div class="App__MainContent-nie0ws-2 huPxDo"><div><div class="LinkButtonList__StyledLearnButtons-jdwpw0-1 lnLSqJ"><span class="LinkButtonList__StyledButtonContainer-jdwpw0-0 eGrpnG"><a tabindex="0" class="jss80 jss109 jss120 jss122 jss123 jss125 Button__StyledButton-sc-1g3in10-0 bjcAIm" role="button" text="A-star" href="https://ninaolo.github.io/code-yay/learn/algorithms/a-star"><span class="jss110">A-star</span><span class="jss83"></span></a></span><span class="LinkButtonList__StyledButtonContainer-jdwpw0-0 eGrpnG"><a tabindex="0" class="jss80 jss109 jss120 jss122 jss123 jss125 Button__StyledButton-sc-1g3in10-0 bjcAIm" role="button" text="BFS graph" href="https://ninaolo.github.io/code-yay/learn/algorithms/bfs-graph"><span class="jss110">BFS graph</span><span class="jss83"></span></a></span><span class="LinkButtonList__StyledButtonContainer-jdwpw0-0 eGrpnG"><a tabindex="0" class="jss80 jss109 jss120 jss122 jss123 jss125 Button__StyledButton-sc-1g3in10-0 bjcAIm" role="button" text="DFS graph" href="https://ninaolo.github.io/code-yay/learn/algorithms/dfs-graph"><span class="jss110">DFS graph</span><span class="jss83"></span></a></span><span class="LinkButtonList__StyledButtonContainer-jdwpw0-0 eGrpnG"><a tabindex="0" class="jss80 jss109 jss120 jss122 jss123 jss125 Button__StyledButton-sc-1g3in10-0 bjcAIm" role="button" text="Dijkstras" href="https://ninaolo.github.io/code-yay/learn/algorithms/dijkstras"><span class="jss110">Dijkstras</span><span class="jss83"></span></a></span><span class="LinkButtonList__StyledButtonContainer-jdwpw0-0 eGrpnG"><a tabindex="0" class="jss80 jss109 jss120 jss122 jss123 jss125 Button__StyledButton-sc-1g3in10-0 bjcAIm" role="button" text="BST traversal" href="https://ninaolo.github.io/code-yay/learn/algorithms/bst-traversal"><span class="jss110">BST traversal</span><span class="jss83"></span></a></span><span class="LinkButtonList__StyledButtonContainer-jdwpw0-0 eGrpnG"><a tabindex="0" class="jss80 jss109 jss120 jss122 jss123 jss125 Button__StyledButton-sc-1g3in10-0 bjcAIm" role="button" text="Topological sort" href="https://ninaolo.github.io/code-yay/learn/algorithms/topological-sort"><span class="jss110">Topological sort</span><span class="jss83"></span></a></span></div></div></div></div></div><script type="text/javascript">window.__CSS_CHUNKS__ = {"main":"https://ninaolo.github.io/code-yay/styles.279679c8.css"}</script><script type="text/javascript">
    window.__routeInfo = {"path":"learn/algorithms","templateID":2,"sharedPropsHashes":{},"localProps":null,"allProps":{"node":{"route":"algorithms","text":"Algorithms","children":[{"text":"A-star","slug":"a-star","fullPath":"/learn/algorithms/a-star","content":{"title":"A-star","slug":"a-star","what":"More general case of Dijkstra's. Finds the (approximated) shortest path between two nodes. Uses a heuristic h computing the approximated distance left to the goal. In Dijkstra's, h = 0 for all nodes.","contents":""}},{"text":"BFS graph","slug":"bfs-graph","fullPath":"/learn/algorithms/bfs-graph","content":{"title":"Breadth First Search (BFS) for graphs","slug":"bfs-graph","worstTime":"O(V + E), if we're searching for something, every edge and every vertex has to be looked at.","contents":"<h3 id=\"difference-from-tree\">Difference from Tree</h3>\n<p>Must also keep track of visited nodes to avoid going in circles or visiting the same node multiple times.</p>\n<h3 id=\"when-to-use-bfs-over-dfs\">When to use BFS over DFS</h3>\n<ol>\n<li>When we know solution(s) is close to root.</li>\n<li>When we want optimal/closest solution.</li>\n<li>If tree is very deep &amp; solutions rare, BFS could be quicker than DFS.</li>\n</ol>\n"}},{"text":"DFS graph","slug":"dfs-graph","fullPath":"/learn/algorithms/dfs-graph","content":{"title":"Depth First Search (DFS) for graphs","slug":"dfs-graph","worstTime":"O(V + E), if we're searching for something, every edge and every vertex has to be looked at.","contents":"<h3 id=\"difference-from-tree\">Difference from Tree</h3>\n<p>Must also keep track of visited nodes to avoid going in circles or visiting the same node multiple times.</p>\n<h3 id=\"when-to-use-dfs-over-bfs\">When to use DFS over BFS</h3>\n<ol>\n<li>When there are many neighbors/branching factor is high –&gt; then BFS takes up much space &amp; DFS is better.</li>\n<li>When there are many solutions but they are deep in the tree/graph.</li>\n<li>When it’s okay that we get a sub-optimal solution (not guaranteed shortest from source.</li>\n</ol>\n"}},{"text":"Dijkstras","slug":"dijkstras","fullPath":"/learn/algorithms/dijkstras","content":{"title":"Dijkstra's algorithm","slug":"dijkstras","what":"Finds the shortest path to all vertices in a Directed Weighted Graph (easily modified for undirected) given a start vertex.","how":"Given a start vertex. | Put start vertex in queue (min-heap). | While queue is not empty... | Poll the queue for the current vertex. | Go through its adjacency list (list of edges). | For all edges, find neighbors and evaluate cost to get there from current. | If lower than current min, update min-heap with the new values.","averageTime":"O(E log V) with a binary heap, because we go through all vertices and do poll() --> O(V log V). In the inner loop we go though all edges and possibly do a decreaseKey-operation --> O(E log V). Final complexity is O(V log V) + O(E log V) = O(E log V). With a fibonacci heap it's O(E + V log V).","space":"Adjacency list --> O(V + E). Adjacency matrix --> O(V^2).","contents":"<h3 id=\"constraints\">Constraints</h3>\n<p>Original/simple version doesn’t work with negative weights (but the below does). However, it doesn’t work if we have cycles with negative sum (will loop forever). The Bellman–Ford algorithm can be used in such cases.</p>\n<h3 id=\"some-information\">Some information</h3>\n<p>Original algorithm doesn’t use a min-priority queue –&gt; O(V^2). A min-priority queue is an optimization (even faster if it’s a Fibonacci heap).</p>\n<p>This is asymptotically the fastest known single-source shortest-path algorithm for directed graphs with unbounded, non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can be improved further.</p>\n<h3 id=\"different-implementations\">Different implementations</h3>\n<p>There are different ways to represent a graph.</p>\n<ul>\n<li>Adjacency Matrix is preferable when we expect the graph to be dense.</li>\n<li>Adjacency List is preferable when we expect the graph to be sparse.</li>\n</ul>\n<h3 id=\"implementation\">Implementation</h3>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    /**\n     * Update the min-distances and predecessors on all vertices given a certain source vertex.\n     */\n    public static void updateDijkstraDistances(Vertex source) {\n        source.setMinDistance(0);\n        PriorityQueue&amp;lt;Vertex&amp;gt; vertexQueue = new PriorityQueue&lt;&gt;();\n        vertexQueue.add(source);\n\n        while (!vertexQueue.isEmpty()) {\n\n            // Get and remove the current prioritized vertex &amp; visit all of its edges.\n            Vertex current = vertexQueue.poll();\n\n            for (Edge edge : current.getEdges()) {\n                Vertex neighbor = edge.getDestination();\n                double distanceToNeighbor = current.getMinDistance() + edge.getCost();\n\n                // If we found a new min distance to the neighbor, update it. Note: remove\n                // is O(V) and add is O(log V) so the optimized Dijkstra should use a\n                // decreaseKey-operation with O(log V) time, but I&#39;m using this for simplicity.\n                if (distanceToNeighbor &lt; neighbor.getMinDistance()) {\n                    vertexQueue.remove(neighbor);\n                    neighbor.setMinDistance(distanceToNeighbor);\n                    neighbor.setPredecessor(current);\n                    vertexQueue.add(neighbor);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">\npublic class Graph {\n\n    private Vertex[] vertices;\n\n    public Graph(Vertex[] vertices) {\n        this.vertices = vertices;\n    }\n\n    public Vertex[] getVertices() {\n        return vertices;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Vertex {\n\n    // Properties representing the vertex itself.\n    private int id;\n    private Edge[] adjacencyList;\n\n    // Properties updated by the Dijkstra algorithm depending on a given source vertex.\n    private double minDistance = Double.POSITIVE_INFINITY;\n    private Vertex predecessor;\n\n    public Vertex(int id) {\n        this.id = id;\n    }\n\n    // This is needed in order to put this object in a priority queue.\n    public int compareTo(Vertex other) {\n        Double.compare(minDistance, other.minDistance);\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Edge[] getEdges() {\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\n    }\n\n    public void setEdges(Edge[] adjacencyList) {\n        this.adjacencyList = adjacencyList;\n    }\n\n    public double getMinDistance() {\n        return minDistance;\n    }\n\n    public Vertex getPredecessor() {\n        return predecessor;\n    }\n\n    public void setMinDistance(double minDistance) {\n        this.minDistance = minDistance;\n    }\n\n    public void setPredecessor(Vertex predecessor) {\n        this.predecessor = predecessor;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Edge {\n\n    private Vertex destination;\n    private double weight;\n\n    public Edge(Vertex destination, double weight) {\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    public Vertex getDestination() {\n        return destination;\n    }\n\n    public double getWeight() {\n        return weight;\n    }\n}\n</code></pre>\n"}},{"text":"BST traversal","slug":"bst-traversal","fullPath":"/learn/algorithms/bst-traversal","content":{"title":"Binary search tree traversal","slug":"bst-traversal","what":"There is pre-order, in-order and post-order traversal.","how":"Recursively go through a binary tree. We have current, left and right node. | Pre-order; current is \"pre\"/before --> current, left, right. | In-order; current is \"in\"/middle --> left, current, right. | Post-order; current is \"post\"/after --> left, right, current.","contents":"<h3 id=\"implementation\">Implementation</h3>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    public static void preOrderTraversal(Node node) {\n        if (node != null) {\n            System.out.println(node); // Current\n            inOrderTraversal(node.getLeft()); // Left\n            inOrderTraversal(node.getRight()); // Right\n        }\n    }\n\n    public static void inOrderTraversal(Node node) {\n        if (node != null) {\n            inOrderTraversal(node.getLeft()); // Left\n            System.out.println(node); // Current\n            inOrderTraversal(node.getRight()); // Right\n        }\n    }\n\n    public static void preOrderTraversal(Node node) {\n        if (node != null) {\n            inOrderTraversal(node.getLeft()); // Left\n            inOrderTraversal(node.getRight()); // Right\n            System.out.println(node); // Current\n        }\n    }\n}\n</code></pre>\n"}},{"text":"Topological sort","slug":"topological-sort","fullPath":"/learn/algorithms/topological-sort","content":{"title":"Topological sort (graphs)","slug":"topological-sort","what":"Ordering for DAG's. Every parent must come before its child. Can be multiple for same graph.","how":"Kind of like DFS but with extra stack (recursion stack + stack).","averageTime":"Same as DFS --> O(E + V).","contents":"<h3 id=\"example-applications\">Example applications</h3>\n<ol>\n<li>Scheduling jobs with dependencies given as graph.</li>\n<li>Finding order of compilation tasks to perform in makefiles.</li>\n</ol>\n<h3 id=\"implementation\">Implementation</h3>\n<pre><code class=\"lang-java\">public class Codeyay {\n\n    /*\n     * Topological sort for one entire DAG.\n     */\n    public static void topologicalSort(Graph graph) {\n        Stack&amp;lt;Vertex&amp;gt; stack = new Stack&lt;&gt;();\n        Set&amp;lt;Integer&amp;gt; visited = new HashSet&lt;&gt;();\n\n        // Go through entire graph.\n        for (Vertex current : graph.getVertices()) {\n            if (!visited.contains(current.getId())) {\n                topologicalSort(current, stack, visited);\n            }\n        }\n\n        // Print the stack.\n        while (!stack.isEmpty()) {\n            System.out.println(stack.pop().getId());\n        }\n    }\n\n    /*\n     * Recursive part of topological sort.\n     */\n    private static void topologicalSort(Vertex current, Stack&amp;lt;Vertex&amp;gt; stack, Set&amp;lt;Integer&amp;gt; visited) {\n        visited.add(current.getId());\n\n        for (Edge edge : current.getEdges()) {\n            Vertex neighbor = edge.getDestination();\n            if (!visited.contains(neighbor.getId())) {\n                topologicalSort(neighbor, stack, visited);\n            }\n        }\n\n        stack.push(current);\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Graph {\n\n    private Vertex[] vertices;\n\n    public Graph(Vertex[] vertices) {\n        this.vertices = vertices;\n    }\n\n    public Vertex[] getVertices() {\n        return vertices;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Vertex {\n\n    private int id;\n    private Edge[] adjacencyList;\n\n    public Vertex(int id) {\n        this.id = id;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Edge[] getEdges() {\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\n    }\n\n    public void setEdges(Edge[] adjacencyList) {\n        this.adjacencyList = adjacencyList;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">public class Edge {\n\n    private Vertex destination;\n    private double weight;\n\n    public Edge(Vertex destination, double weight) {\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    public Vertex getDestination() {\n        return destination;\n    }\n\n    public double getWeight() {\n        return weight;\n    }\n}\n</code></pre>\n<pre><code class=\"lang-java\">\n</code></pre>\n"}}],"fullPath":"/learn/algorithms"}},"siteData":{"title":"code-yay"}};</script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/bootstrap.85a21347.js"></script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/templates/src/containers/Learn.7222bb7b.js"></script><script defer="" type="text/javascript" src="https://ninaolo.github.io/code-yay/main.73dea303.js"></script></body></html>