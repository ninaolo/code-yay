{"template":"/Users/Nina/git/code-yay/src/components/LearnNode.tsx","sharedHashesByProp":{},"data":{"node":{"text":"Topological sort","slug":"topological-sort","fullPath":"/learn/algorithms/topological-sort","content":{"title":"Topological sort (graphs)","slug":"topological-sort","what":"Ordering for DAG's. Every parent must come before its child. Can be multiple for same graph.","how":"Kind of like DFS but with extra stack (recursion stack + stack).","averageTime":"Same as DFS --> O(E + V).","contents":"<h3 id=\"example-applications\">Example applications</h3>\n<ol>\n<li>Scheduling jobs with dependencies given as graph.</li>\n<li>Finding order of compilation tasks to perform in makefiles.</li>\n</ol>\n<h3 id=\"implementation\">Implementation</h3>\n<pre><code class=\"language-java\">public class Codeyay {\n\n    /*\n     * Topological sort for one entire DAG.\n     */\n    public static void topologicalSort(Graph graph) {\n        Stack&amp;lt;Vertex&amp;gt; stack = new Stack&lt;&gt;();\n        Set&amp;lt;Integer&amp;gt; visited = new HashSet&lt;&gt;();\n\n        // Go through entire graph.\n        for (Vertex current : graph.getVertices()) {\n            if (!visited.contains(current.getId())) {\n                topologicalSort(current, stack, visited);\n            }\n        }\n\n        // Print the stack.\n        while (!stack.isEmpty()) {\n            System.out.println(stack.pop().getId());\n        }\n    }\n\n    /*\n     * Recursive part of topological sort.\n     */\n    private static void topologicalSort(Vertex current, Stack&amp;lt;Vertex&amp;gt; stack, Set&amp;lt;Integer&amp;gt; visited) {\n        visited.add(current.getId());\n\n        for (Edge edge : current.getEdges()) {\n            Vertex neighbor = edge.getDestination();\n            if (!visited.contains(neighbor.getId())) {\n                topologicalSort(neighbor, stack, visited);\n            }\n        }\n\n        stack.push(current);\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class Graph {\n\n    private Vertex[] vertices;\n\n    public Graph(Vertex[] vertices) {\n        this.vertices = vertices;\n    }\n\n    public Vertex[] getVertices() {\n        return vertices;\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class Vertex {\n\n    private int id;\n    private Edge[] adjacencyList;\n\n    public Vertex(int id) {\n        this.id = id;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public Edge[] getEdges() {\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\n    }\n\n    public void setEdges(Edge[] adjacencyList) {\n        this.adjacencyList = adjacencyList;\n    }\n}</code></pre>\n<pre><code class=\"language-java\">public class Edge {\n\n    private Vertex destination;\n    private double weight;\n\n    public Edge(Vertex destination, double weight) {\n        this.destination = destination;\n        this.weight = weight;\n    }\n\n    public Vertex getDestination() {\n        return destination;\n    }\n\n    public double getWeight() {\n        return weight;\n    }\n}</code></pre>\n"}}},"path":"learn/algorithms/topological-sort"}
