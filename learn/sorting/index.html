<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><link rel="preload" as="script" href="https://codercatch.com/templates/Users/Nina/git/code-yay/src/containers/Learn.tsx.491b9dad.js"/><link rel="preload" as="script" href="https://codercatch.com/templates/vendors~main.77f775ef.js"/><link rel="preload" as="script" href="https://codercatch.com/main.d81d40e8.js"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/></head><body><div id="root"><div style="outline:none" tabindex="-1" role="group"><div class="sc-EHOje gghtrN"><div class="sc-bZQynM bnbpXH"><div class="sc-bdVaJa UoSJW"><header class="MuiPaper-root MuiPaper-elevation4 MuiAppBar-root MuiAppBar-positionStatic MuiAppBar-colorPrimary"><div class="MuiToolbar-root MuiToolbar-regular MuiToolbar-gutters"><a href="https://codercatch.com/">coder â€¢ catch</a><div class="sc-bwzfXH fZWKdm"></div><div class="sc-bxivhb daznuY"><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/interview-prep">Interview prep</a></li><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/blog">Blog</a></li><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/about">About</a></li></div><div class="sc-htpNat dlQEJK"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit" tabindex="0" type="button" aria-haspopup="true"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span></button></div></div></header></div></div><div class="sc-gzVnrw jkZyAP"><div style="outline:none" tabindex="-1" role="group"><div><div class="sc-iwsKbI dpGLLW"><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Bubble sort" href="https://codercatch.com/learn/sorting/bubble-sort"><span class="MuiButton-label">Bubble sort</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Heap sort" href="https://codercatch.com/learn/sorting/heap-sort"><span class="MuiButton-label">Heap sort</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Insertion sort" href="https://codercatch.com/learn/sorting/insertion-sort"><span class="MuiButton-label">Insertion sort</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Merge sort" href="https://codercatch.com/learn/sorting/merge-sort"><span class="MuiButton-label">Merge sort</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Quick sort" href="https://codercatch.com/learn/sorting/quick-sort"><span class="MuiButton-label">Quick sort</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Comparison" href="https://codercatch.com/learn/sorting/sorting-comparison"><span class="MuiButton-label">Comparison</span></a></span></div></div></div></div></div></div></div><script type="text/javascript">
    window.__routeInfo = JSON.parse("{\"template\":\"/Users/Nina/git/code-yay/src/containers/Learn.tsx\",\"sharedHashesByProp\":{},\"data\":{\"node\":{\"route\":\"sorting\",\"text\":\"Sorting\",\"children\":[{\"text\":\"Bubble sort\",\"slug\":\"bubble-sort\",\"fullPath\":\"/learn/sorting/bubble-sort\",\"content\":{\"title\":\"Bubble sort\",\"slug\":\"bubble-sort\",\"what\":\"A very simple sorting algorithm using double for-loops. It's slow and has a quite na\u00EFve approach.\",\"how\":\"For every element... | For every pair of elements... | If left is greater than right - swap\",\"bestTime\":\"O(N) when already sorted\",\"worstTime\":\"O(N)^2 because of double for loops\",\"averageTime\":\"O(N)^2\",\"space\":\"O(1)\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static void swap(int iFirst, int iSecond, Comparable[] list) {\\n        Comparable tmp = list[iFirst];\\n        list[iFirst] = list[iSecond];\\n        list[iSecond] = tmp;\\n    }\\n\\n    public static void bubbleSort(Comparable[] list) {\\n\\n        // Traverse list. For every element, traverse list with swapping pairs.\\n        // Note that iTraverse stops before last element and iPair goes to the last element.\\n        for (int iTraverse = 0; iTraverse &lt; list.length - 1; iTraverse++) {\\n            for (int iPair = 1; iPair &lt; list.length; iPair++) {\\n\\n                // Swap if left &gt; right.\\n                if (list[iPair - 1].compareTo(list[iPair]) &gt; 0) {\\n                    swap(iPair - 1, iPair, list);\\n                }\\n            }\\n        }\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Heap sort\",\"slug\":\"heap-sort\",\"fullPath\":\"/learn/sorting/heap-sort\",\"content\":{\"title\":\"Heap sort\",\"slug\":\"heap-sort\",\"what\":\"Sorts by using a heap. The input array can be used as the actual heap --> no additional storage.\",\"how\":\"Turn array into max-heap --> O(N) | Swap root N times with last element & make sure new root comes to right place --> O(N log N)\",\"bestTime\":\"O(N + N log N) = O(N log N)\",\"averageTime\":\"O(N + N log N) = O(N log N)\",\"worstTime\":\"O(N + N log N) = O(N log N)\",\"space\":\"O(1)\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static void heapSort(Comparable[] array) {\\n        int n = array.length;\\n\\n        // STEP 1: build heap bottom-up (begin at lowest level with children) --&gt; O(N).\\n        for (int i = n / 2 - 1; i &gt;= 0; i--) {\\n            heapify(array, i, n);\\n        }\\n\\n        // STEP 2: swap max root with last child, heapify on the smaller heap --&gt; O(N log N).\\n        for (int iLast = n - 1; iLast &gt;= 0; iLast--) {\\n            swap(0, iLast, array);\\n            heapify(array, 0, iLast);\\n        }\\n    }\\n\\n    private static void heapify(Comparable[] array, int iSubRoot, int heapSize) {\\n        int iLeft = iSubRoot * 2 + 1;\\n        int iRight = iSubRoot * 2 + 2;\\n        int iLargest = iSubRoot;\\n\\n        if (iLeft &lt; heapSize &amp;&amp; array[iLeft].compareTo(array[iLargest]) &gt; 0) {\\n            iLargest = iLeft;\\n        }\\n\\n        if (iRight &lt; heapSize &amp;&amp; array[iRight].compareTo(array[iLargest]) &gt; 0) {\\n            iLargest = iRight;\\n        }\\n\\n        if (iLargest != iSubRoot) {\\n            swap(iLargest, iSubRoot, array);\\n\\n            // Recursively heapify the new subtree.\\n            heapify(array, iLargest, heapSize);\\n        }\\n    }\\n\\n    private static void swap(int iFirst, int iSecond, Comparable[] array) {\\n        Comparable tmp = array[iFirst];\\n        array[iFirst] = array[iSecond];\\n        array[iSecond] = tmp;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Insertion sort\",\"slug\":\"insertion-sort\",\"fullPath\":\"/learn/sorting/insertion-sort\",\"content\":{\"title\":\"Insertion sort\",\"slug\":\"insertion-sort\",\"what\":\"Stable sort with simple/compact code which sorts incrementally.\",\"bestTime\":\"O(N) already/nearly sorted\",\"worstTime\":\"O(N^2) sorted backwards\",\"space\":\"O(1)\",\"pros\":\"good for small N, stable sort, doesn't use recursion, no additional space used\",\"cons\":\"slow for large N\",\"info\":\"For these reasons it's often used as the recursive base case (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as merge sort or quick sort.\",\"contents\":\"\"}},{\"text\":\"Merge sort\",\"slug\":\"merge-sort\",\"fullPath\":\"/learn/sorting/merge-sort\",\"content\":{\"title\":\"Merge sort\",\"slug\":\"merge-sort\",\"what\":\"Divide-and-conquer algorithm that sorts by repeatedly dividing the list in two and then merging the two sub-lists. Usually implemented with array copies and therefore takes up some extra space.\",\"how\":\"Split list in two | Recursively sort left part | Recursively sort right part | Merge\",\"bestTime\":\"O(N log N)\",\"averageTime\":\"O(N log N)\",\"worstTime\":\"O(N log N)\",\"space\":\"O(N) for extra storage\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static void merge(Comparable[] left, Comparable[] right, Comparable[] list) {\\n\\n        // Define the indexes.\\n        int iLeft = 0;\\n        int iRight = 0;\\n        int iList = 0;\\n\\n        // Loop and copy the smallest element each time from left/right list.\\n        while (iLeft &lt; left.length &amp;&amp; iRight &lt; right.length) {\\n            if (left[iLeft].compareTo(right[iRight]) &lt; 0) {\\n                list[iList] = left[iLeft];\\n                iLeft++;\\n            } else {\\n                list[iList] = right[iRight];\\n                iRight++;\\n            }\\n            iList++;\\n        }\\n\\n        // Copy elements that are left.\\n        System.arraycopy(left, iLeft, list, iList, left.length - iLeft);\\n        System.arraycopy(right, iRight, list, iList, right.length - iRight);\\n    }\\n\\n    public static void mergeSort(Comparable[] list) {\\n\\n        // Base case - otherwise infinite recursion.\\n        if (list.length == 1) {\\n            return;\\n        }\\n\\n        // Split in two, creating two new lists in memory and copying the elements.\\n        Comparable[] left = new Comparable[list.length / 2];\\n        Comparable[] right = new Comparable[list.length - left.length];\\n        System.arraycopy(list, 0, left, 0, left.length);\\n        System.arraycopy(list, left.length, right, 0, right.length);\\n\\n        // Recursively sort both halves.\\n        mergeSort(left);\\n        mergeSort(right);\\n\\n        // Merge the two sorted parts.\\n        merge(left, right, list);\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Quick sort\",\"slug\":\"quick-sort\",\"fullPath\":\"/learn/sorting/quick-sort\",\"content\":{\"title\":\"Quick sort\",\"slug\":\"quick-sort\",\"what\":\"Divide-and-conquer algorithm that sorts with the help of a pivot value.\",\"how\":\"Choose pivot | Move small values to the left of pivot, greater to the right | Recursively sort left and right part\",\"averageTime\":\"O(N log N)\",\"bestTime\":\"O(N log N)\",\"worstTime\":\"O(N^2) for example if first element is pivot in already sorted list\",\"space\":\"O(log N) for recursion\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static void swap(int iFirst, int iSecond, Comparable[] list) {\\n        Comparable tmp = list[iFirst];\\n        list[iFirst] = list[iSecond];\\n        list[iSecond] = tmp;\\n    }\\n\\n    private static int getAndPlacePivot(Comparable[] list, int iLeft, int iRight) {\\n\\n        // Choose last element as pivot. Any element could be chosen, but this is one strategy.\\n        Comparable pivot = list[iRight];\\n\\n        // Keep track of the last seen small value (smaller than pivot).\\n        int iLastSmall = iLeft - 1;\\n\\n        // Step forward. If high value, do nothing. If low value, swap low to the left side.\\n        for (int iCurrent = iLeft; iCurrent &lt; iRight; iCurrent++) {\\n            if (list[iCurrent].compareTo(pivot) &lt;= 0) {\\n                swap(iLastSmall + 1, iCurrent, list);\\n                iLastSmall++;\\n            }\\n        }\\n\\n        // Swap the first high value with the pivot, putting it into the right position.\\n        swap(iLastSmall + 1, iRight, list);\\n        return iLastSmall + 1;\\n    }\\n\\n    public static void quickSort(Comparable[] list, int iLeft, int iRight) {\\n\\n        // Base case - otherwise infinite recursion.\\n        if (iLeft &gt;= iRight) {\\n            return;\\n        }\\n\\n        // Get pivot index at correct place in list (smaller to the left and greater to the right).\\n        int iPivot = getAndPlacePivot(list, iLeft, iRight);\\n\\n        // Recursively sort elements to the left and right side of the iPivot.\\n        quickSort(list, iLeft, iPivot - 1);\\n        quickSort(list, iPivot + 1, iRight);\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Comparison\",\"slug\":\"sorting-comparison\",\"fullPath\":\"/learn/sorting/sorting-comparison\",\"content\":{\"title\":\"Sorting comparison\",\"slug\":\"sorting-comparison\",\"contents\":\"<h3 id=\\\"quicksort-vs-mergesort\\\">Quicksort vs Mergesort</h3>\\n<h4 id=\\\"comparison\\\">Comparison</h4>\\n<ol>\\n<li>Mergesort is often a little slower than Quicksort. Why? It has a worse locality of reference\\nso access is faster in Quicksort than Mergesort.</li>\\n<li>Mergesort guarantees O(N log N) --&gt; reliable, even if we have already sorted\\nor equal elements. Quicksort doesn&#39;t, worst case is O(N^2). However, the worst case can be made very rare if\\nyou choose a good pivot.</li>\\n<li>Mergesort is a stable sort (doesn&#39;t reorder identical elements). Quicksort isn&#39;t.</li>\\n<li>Mergesort uses more space O(N) because the overhead of merging. Quicksort only uses O(log N) for\\nrecursion stack space.</li>\\n</ol>\\n<h4 id=\\\"mergesort-when-to-use-\\\">Mergesort - when to use?</h4>\\n<ol>\\n<li>When worst case matters and you really can&#39;t have O(N^2).</li>\\n<li>When you have a linked list. Nodes are scattered throughout memory so locality of reference doesn&#39;t matter.\\nAlso, space required for merging linked lists is O(1) and not O(N).</li>\\n</ol>\\n<h4 id=\\\"quicksort-when-to-use-\\\">Quicksort - when to use?</h4>\\n<ol>\\n<li>When worst case doesn&#39;t matter, and you want the one that is generally quicker.</li>\\n<li>When space is limited.</li>\\n</ol>\\n<h3 id=\\\"heapsort-the-best-\\\">HeapSort - the best?</h3>\\n<p>Might seem so with O(1) space and O(N log N) best/worst/average. BUT...</p>\\n<ol>\\n<li>In practice QuickSort + MergeSort have smaller constants (they&#39;re quicker) which doesn&#39;t show in Big-O.</li>\\n<li>HeapSort is not stable.</li>\\n</ol>\\n<h3 id=\\\"other\\\">Other</h3>\\n<p>Don&#39;t use Bubblesort. Has advantage on already sorted lists O(N), but that&#39;s about it.</p>\\n\"}}],\"fullPath\":\"/learn/sorting\"}},\"path\":\"learn/sorting\",\"sharedData\":{},\"siteData\":{\"title\":\"code-yay\"}}");</script><script defer="" type="text/javascript" src="https://codercatch.com/templates/Users/Nina/git/code-yay/src/containers/Learn.tsx.491b9dad.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/templates/vendors~main.77f775ef.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/main.d81d40e8.js"></script></body></html>