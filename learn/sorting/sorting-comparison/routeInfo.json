{"path":"learn/sorting/sorting-comparison","templateID":2,"sharedPropsHashes":{},"localProps":{"node":{"text":"Comparison","slug":"sorting-comparison","fullPath":"/learn/sorting/sorting-comparison","content":{"title":"Sorting comparison","slug":"sorting-comparison","contents":"<h3 id=\"quicksort-vs-mergesort\">Quicksort vs Mergesort</h3>\n<h4 id=\"comparison\">Comparison</h4>\n<ol>\n<li>Mergesort is often a little slower than Quicksort. Why? It has a worse locality of reference\nso access is faster in Quicksort than Mergesort.</li>\n<li>Mergesort guarantees O(N log N) –&gt; reliable, even if we have already sorted\nor equal elements. Quicksort doesn’t, worst case is O(N^2). However, the worst case can be made very rare if\nyou choose a good pivot.</li>\n<li>Mergesort is a stable sort (doesn’t reorder identical elements). Quicksort isn’t.</li>\n<li>Mergesort uses more space O(N) because the overhead of merging. Quicksort only uses O(log N) for\nrecursion stack space.</li>\n</ol>\n<h4 id=\"mergesort-when-to-use-\">Mergesort - when to use?</h4>\n<ol>\n<li>When worst case matters and you really can’t have O(N^2).</li>\n<li>When you have a linked list. Nodes are scattered throughout memory so locality of reference doesn’t matter.\nAlso, space required for merging linked lists is O(1) and not O(N).</li>\n</ol>\n<h4 id=\"quicksort-when-to-use-\">Quicksort - when to use?</h4>\n<ol>\n<li>When worst case doesn’t matter, and you want the one that is generally quicker.</li>\n<li>When space is limited.</li>\n</ol>\n<h3 id=\"heapsort-the-best-\">HeapSort - the best?</h3>\n<p>Might seem so with O(1) space and O(N log N) best/worst/average. BUT…</p>\n<ol>\n<li>In practice QuickSort + MergeSort have smaller constants (they’re quicker) which doesn’t show in Big-O.</li>\n<li>HeapSort is not stable.</li>\n</ol>\n<h3 id=\"other\">Other</h3>\n<p>Don’t use Bubblesort. Has advantage on already sorted lists O(N), but that’s about it.</p>\n"}}}}
