<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><link rel="preload" as="script" href="https://codercatch.com/templates/Users/Nina/git/code-yay/src/containers/Learn.tsx.491b9dad.js"/><link rel="preload" as="script" href="https://codercatch.com/templates/vendors~main.77f775ef.js"/><link rel="preload" as="script" href="https://codercatch.com/main.54a1ef68.js"/><style data-styled="gghtrN bnbpXH UoSJW fZWKdm daznuY dlQEJK jkZyAP cbNEgI" data-styled-version="4.3.2">
/* sc-component-id: sc-bdVaJa */
.UoSJW{width:100%;}
/* sc-component-id: sc-bwzfXH */
.fZWKdm{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}
/* sc-component-id: sc-htpNat */
.dlQEJK{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;} @media (min-width:960px){.dlQEJK{display:none;}}
/* sc-component-id: sc-bxivhb */
.daznuY{display:none;} @media (min-width:960px){.daznuY{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}
/* sc-component-id: sc-ifAKCX */
.cbNEgI.cbNEgI{border-radius:1.5rem;padding:3rem;width:200px;text-transform:none;box-shadow:none;color:white;font-family:Lato;font-size:15px;}
/* sc-component-id: sc-global-1865284974 */
body{font-family:Lato;font-weight:400;-webkit-letter-spacing:0.3px;-moz-letter-spacing:0.3px;-ms-letter-spacing:0.3px;letter-spacing:0.3px;line-height:1.5;font-size:15px;margin:0;padding:0;color:#4e4e4e;}
/* sc-component-id: sc-EHOje */
.gghtrN a{-webkit-text-decoration:none;text-decoration:none;color:#704f56;font-weight:bold;} .gghtrN img{max-width:100%;} .gghtrN h1,.gghtrN h2,.gghtrN h3,.gghtrN h4,.gghtrN h5{color:#1e1e1e;}
/* sc-component-id: sc-bZQynM */
.bnbpXH a,.bnbpXH span{color:white;font-family:Lato;}
/* sc-component-id: sc-gzVnrw */
.jkZyAP{padding:3% 5%;} .jkZyAP p > code{background:#f4f4f4;padding:.1em .5em;border-radius:.3em;white-space:normal;font-family:Lato;-webkit-letter-spacing:0.8px;-moz-letter-spacing:0.8px;-ms-letter-spacing:0.8px;letter-spacing:0.8px;}</style><style data-styled="dpGLLW dIZNHa" data-styled-version="4.3.2">
/* sc-component-id: sc-dnqmqq */
.dIZNHa{margin:1em 0;}
/* sc-component-id: sc-iwsKbI */
.dpGLLW{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:space-evenly;-webkit-justify-content:space-evenly;-ms-flex-pack:space-evenly;justify-content:space-evenly;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-align-content:space-evenly;-ms-flex-line-pack:space-evenly;align-content:space-evenly;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}</style><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/></head><body><div id="root"><div style="outline:none" tabindex="-1" role="group"><div class="sc-EHOje gghtrN"><div class="sc-bZQynM bnbpXH"><div class="sc-bdVaJa UoSJW"><header class="MuiPaper-root MuiPaper-elevation4 MuiAppBar-root MuiAppBar-positionStatic MuiAppBar-colorPrimary"><div class="MuiToolbar-root MuiToolbar-regular MuiToolbar-gutters"><a href="https://codercatch.com/">coder â€¢ catch</a><div class="sc-bwzfXH fZWKdm"></div><div class="sc-bxivhb daznuY"><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/interview-prep">Interview prep</a></li><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/blog">Blog</a></li><li class="MuiButtonBase-root MuiListItem-root MuiMenuItem-root MuiMenuItem-gutters MuiListItem-gutters MuiListItem-button" tabindex="-1" role="menuitem" aria-disabled="false"><a href="https://codercatch.com/about">About</a></li></div><div class="sc-htpNat dlQEJK"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit" tabindex="0" type="button" aria-haspopup="true"><span class="MuiIconButton-label"><svg class="MuiSvgIcon-root" focusable="false" viewBox="0 0 24 24" aria-hidden="true" role="presentation"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></span></button></div></div></header></div></div><div class="sc-gzVnrw jkZyAP"><div style="outline:none" tabindex="-1" role="group"><div><div class="sc-iwsKbI dpGLLW"><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Sorting" href="https://codercatch.com/learn/sorting"><span class="MuiButton-label">Sorting</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Problems" href="https://codercatch.com/learn/problems"><span class="MuiButton-label">Problems</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Algorithms" href="https://codercatch.com/learn/algorithms"><span class="MuiButton-label">Algorithms</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Concepts" href="https://codercatch.com/learn/concepts"><span class="MuiButton-label">Concepts</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Languages" href="https://codercatch.com/learn/languages"><span class="MuiButton-label">Languages</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Datastructures" href="https://codercatch.com/learn/datastructures"><span class="MuiButton-label">Datastructures</span></a></span><span class="sc-dnqmqq dIZNHa"><a class="MuiButtonBase-root MuiButton-root sc-ifAKCX cbNEgI MuiButton-contained MuiButton-containedSecondary" tabindex="0" role="button" aria-disabled="false" text="Other" href="https://codercatch.com/learn/other"><span class="MuiButton-label">Other</span></a></span></div></div></div></div></div></div></div><script type="text/javascript">
    window.__routeInfo = JSON.parse("{\"template\":\"/Users/Nina/git/code-yay/src/containers/Learn.tsx\",\"sharedHashesByProp\":{},\"data\":{\"node\":{\"route\":\"learn\",\"text\":\"Learn\",\"fullPath\":\"/learn\",\"children\":[{\"route\":\"sorting\",\"text\":\"Sorting\",\"children\":[{\"text\":\"Bubble sort\",\"slug\":\"bubble-sort\",\"fullPath\":\"/learn/sorting/bubble-sort\",\"content\":{\"title\":\"Bubble sort\",\"slug\":\"bubble-sort\",\"what\":\"A very simple sorting algorithm using double for-loops. It's slow and has a quite na\u00EFve approach.\",\"how\":\"For every element... | For every pair of elements... | If left is greater than right - swap\",\"bestTime\":\"O(N) when already sorted\",\"worstTime\":\"O(N)^2 because of double for loops\",\"averageTime\":\"O(N)^2\",\"space\":\"O(1)\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static void swap(int iFirst, int iSecond, Comparable[] list) {\\n        Comparable tmp = list[iFirst];\\n        list[iFirst] = list[iSecond];\\n        list[iSecond] = tmp;\\n    }\\n\\n    public static void bubbleSort(Comparable[] list) {\\n\\n        // Traverse list. For every element, traverse list with swapping pairs.\\n        // Note that iTraverse stops before last element and iPair goes to the last element.\\n        for (int iTraverse = 0; iTraverse &lt; list.length - 1; iTraverse++) {\\n            for (int iPair = 1; iPair &lt; list.length; iPair++) {\\n\\n                // Swap if left &gt; right.\\n                if (list[iPair - 1].compareTo(list[iPair]) &gt; 0) {\\n                    swap(iPair - 1, iPair, list);\\n                }\\n            }\\n        }\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Heap sort\",\"slug\":\"heap-sort\",\"fullPath\":\"/learn/sorting/heap-sort\",\"content\":{\"title\":\"Heap sort\",\"slug\":\"heap-sort\",\"what\":\"Sorts by using a heap. The input array can be used as the actual heap --> no additional storage.\",\"how\":\"Turn array into max-heap --> O(N) | Swap root N times with last element & make sure new root comes to right place --> O(N log N)\",\"bestTime\":\"O(N + N log N) = O(N log N)\",\"averageTime\":\"O(N + N log N) = O(N log N)\",\"worstTime\":\"O(N + N log N) = O(N log N)\",\"space\":\"O(1)\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static void heapSort(Comparable[] array) {\\n        int n = array.length;\\n\\n        // STEP 1: build heap bottom-up (begin at lowest level with children) --&gt; O(N).\\n        for (int i = n / 2 - 1; i &gt;= 0; i--) {\\n            heapify(array, i, n);\\n        }\\n\\n        // STEP 2: swap max root with last child, heapify on the smaller heap --&gt; O(N log N).\\n        for (int iLast = n - 1; iLast &gt;= 0; iLast--) {\\n            swap(0, iLast, array);\\n            heapify(array, 0, iLast);\\n        }\\n    }\\n\\n    private static void heapify(Comparable[] array, int iSubRoot, int heapSize) {\\n        int iLeft = iSubRoot * 2 + 1;\\n        int iRight = iSubRoot * 2 + 2;\\n        int iLargest = iSubRoot;\\n\\n        if (iLeft &lt; heapSize &amp;&amp; array[iLeft].compareTo(array[iLargest]) &gt; 0) {\\n            iLargest = iLeft;\\n        }\\n\\n        if (iRight &lt; heapSize &amp;&amp; array[iRight].compareTo(array[iLargest]) &gt; 0) {\\n            iLargest = iRight;\\n        }\\n\\n        if (iLargest != iSubRoot) {\\n            swap(iLargest, iSubRoot, array);\\n\\n            // Recursively heapify the new subtree.\\n            heapify(array, iLargest, heapSize);\\n        }\\n    }\\n\\n    private static void swap(int iFirst, int iSecond, Comparable[] array) {\\n        Comparable tmp = array[iFirst];\\n        array[iFirst] = array[iSecond];\\n        array[iSecond] = tmp;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Insertion sort\",\"slug\":\"insertion-sort\",\"fullPath\":\"/learn/sorting/insertion-sort\",\"content\":{\"title\":\"Insertion sort\",\"slug\":\"insertion-sort\",\"what\":\"Stable sort with simple/compact code which sorts incrementally.\",\"bestTime\":\"O(N) already/nearly sorted\",\"worstTime\":\"O(N^2) sorted backwards\",\"space\":\"O(1)\",\"pros\":\"good for small N, stable sort, doesn't use recursion, no additional space used\",\"cons\":\"slow for large N\",\"info\":\"For these reasons it's often used as the recursive base case (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as merge sort or quick sort.\",\"contents\":\"\"}},{\"text\":\"Merge sort\",\"slug\":\"merge-sort\",\"fullPath\":\"/learn/sorting/merge-sort\",\"content\":{\"title\":\"Merge sort\",\"slug\":\"merge-sort\",\"what\":\"Divide-and-conquer algorithm that sorts by repeatedly dividing the list in two and then merging the two sub-lists. Usually implemented with array copies and therefore takes up some extra space.\",\"how\":\"Split list in two | Recursively sort left part | Recursively sort right part | Merge\",\"bestTime\":\"O(N log N)\",\"averageTime\":\"O(N log N)\",\"worstTime\":\"O(N log N)\",\"space\":\"O(N) for extra storage\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static void merge(Comparable[] left, Comparable[] right, Comparable[] list) {\\n\\n        // Define the indexes.\\n        int iLeft = 0;\\n        int iRight = 0;\\n        int iList = 0;\\n\\n        // Loop and copy the smallest element each time from left/right list.\\n        while (iLeft &lt; left.length &amp;&amp; iRight &lt; right.length) {\\n            if (left[iLeft].compareTo(right[iRight]) &lt; 0) {\\n                list[iList] = left[iLeft];\\n                iLeft++;\\n            } else {\\n                list[iList] = right[iRight];\\n                iRight++;\\n            }\\n            iList++;\\n        }\\n\\n        // Copy elements that are left.\\n        System.arraycopy(left, iLeft, list, iList, left.length - iLeft);\\n        System.arraycopy(right, iRight, list, iList, right.length - iRight);\\n    }\\n\\n    public static void mergeSort(Comparable[] list) {\\n\\n        // Base case - otherwise infinite recursion.\\n        if (list.length == 1) {\\n            return;\\n        }\\n\\n        // Split in two, creating two new lists in memory and copying the elements.\\n        Comparable[] left = new Comparable[list.length / 2];\\n        Comparable[] right = new Comparable[list.length - left.length];\\n        System.arraycopy(list, 0, left, 0, left.length);\\n        System.arraycopy(list, left.length, right, 0, right.length);\\n\\n        // Recursively sort both halves.\\n        mergeSort(left);\\n        mergeSort(right);\\n\\n        // Merge the two sorted parts.\\n        merge(left, right, list);\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Quick sort\",\"slug\":\"quick-sort\",\"fullPath\":\"/learn/sorting/quick-sort\",\"content\":{\"title\":\"Quick sort\",\"slug\":\"quick-sort\",\"what\":\"Divide-and-conquer algorithm that sorts with the help of a pivot value.\",\"how\":\"Choose pivot | Move small values to the left of pivot, greater to the right | Recursively sort left and right part\",\"averageTime\":\"O(N log N)\",\"bestTime\":\"O(N log N)\",\"worstTime\":\"O(N^2) for example if first element is pivot in already sorted list\",\"space\":\"O(log N) for recursion\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static void swap(int iFirst, int iSecond, Comparable[] list) {\\n        Comparable tmp = list[iFirst];\\n        list[iFirst] = list[iSecond];\\n        list[iSecond] = tmp;\\n    }\\n\\n    private static int getAndPlacePivot(Comparable[] list, int iLeft, int iRight) {\\n\\n        // Choose last element as pivot. Any element could be chosen, but this is one strategy.\\n        Comparable pivot = list[iRight];\\n\\n        // Keep track of the last seen small value (smaller than pivot).\\n        int iLastSmall = iLeft - 1;\\n\\n        // Step forward. If high value, do nothing. If low value, swap low to the left side.\\n        for (int iCurrent = iLeft; iCurrent &lt; iRight; iCurrent++) {\\n            if (list[iCurrent].compareTo(pivot) &lt;= 0) {\\n                swap(iLastSmall + 1, iCurrent, list);\\n                iLastSmall++;\\n            }\\n        }\\n\\n        // Swap the first high value with the pivot, putting it into the right position.\\n        swap(iLastSmall + 1, iRight, list);\\n        return iLastSmall + 1;\\n    }\\n\\n    public static void quickSort(Comparable[] list, int iLeft, int iRight) {\\n\\n        // Base case - otherwise infinite recursion.\\n        if (iLeft &gt;= iRight) {\\n            return;\\n        }\\n\\n        // Get pivot index at correct place in list (smaller to the left and greater to the right).\\n        int iPivot = getAndPlacePivot(list, iLeft, iRight);\\n\\n        // Recursively sort elements to the left and right side of the iPivot.\\n        quickSort(list, iLeft, iPivot - 1);\\n        quickSort(list, iPivot + 1, iRight);\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Comparison\",\"slug\":\"sorting-comparison\",\"fullPath\":\"/learn/sorting/sorting-comparison\",\"content\":{\"title\":\"Sorting comparison\",\"slug\":\"sorting-comparison\",\"contents\":\"<h3 id=\\\"quicksort-vs-mergesort\\\">Quicksort vs Mergesort</h3>\\n<h4 id=\\\"comparison\\\">Comparison</h4>\\n<ol>\\n<li>Mergesort is often a little slower than Quicksort. Why? It has a worse locality of reference\\nso access is faster in Quicksort than Mergesort.</li>\\n<li>Mergesort guarantees O(N log N) --&gt; reliable, even if we have already sorted\\nor equal elements. Quicksort doesn&#39;t, worst case is O(N^2). However, the worst case can be made very rare if\\nyou choose a good pivot.</li>\\n<li>Mergesort is a stable sort (doesn&#39;t reorder identical elements). Quicksort isn&#39;t.</li>\\n<li>Mergesort uses more space O(N) because the overhead of merging. Quicksort only uses O(log N) for\\nrecursion stack space.</li>\\n</ol>\\n<h4 id=\\\"mergesort-when-to-use-\\\">Mergesort - when to use?</h4>\\n<ol>\\n<li>When worst case matters and you really can&#39;t have O(N^2).</li>\\n<li>When you have a linked list. Nodes are scattered throughout memory so locality of reference doesn&#39;t matter.\\nAlso, space required for merging linked lists is O(1) and not O(N).</li>\\n</ol>\\n<h4 id=\\\"quicksort-when-to-use-\\\">Quicksort - when to use?</h4>\\n<ol>\\n<li>When worst case doesn&#39;t matter, and you want the one that is generally quicker.</li>\\n<li>When space is limited.</li>\\n</ol>\\n<h3 id=\\\"heapsort-the-best-\\\">HeapSort - the best?</h3>\\n<p>Might seem so with O(1) space and O(N log N) best/worst/average. BUT...</p>\\n<ol>\\n<li>In practice QuickSort + MergeSort have smaller constants (they&#39;re quicker) which doesn&#39;t show in Big-O.</li>\\n<li>HeapSort is not stable.</li>\\n</ol>\\n<h3 id=\\\"other\\\">Other</h3>\\n<p>Don&#39;t use Bubblesort. Has advantage on already sorted lists O(N), but that&#39;s about it.</p>\\n\"}}],\"fullPath\":\"/learn/sorting\"},{\"route\":\"problems\",\"text\":\"Problems\",\"children\":[{\"text\":\"General\",\"slug\":\"problems-general\",\"fullPath\":\"/learn/problems/problems-general\",\"content\":{\"title\":\"General tips for interview problem solving\",\"slug\":\"problems-general\",\"contents\":\"<h3 id=\\\"highest-lowest-product-problems\\\">Highest/lowest product problems</h3>\\n<p>Highest/lowest product doesn&#39;t only involve highest/lowest numbers. Also think of negative numbers --&gt;\\ntwo very large negative numbers multiplied = a large positive. Easy to forget!</p>\\n<h3 id=\\\"finding-a-sum-among-integers\\\">Finding a sum among integers</h3>\\n<p>Not needed to combine all with all (N^2). Previously seen Integers can be stored in a HashMap and the\\nremaining needed number(s) expressed with the sum.</p>\\n<h3 id=\\\"recursion\\\">Recursion</h3>\\n<p>Don&#39;t forget the base case! Otherwise, you&#39;ll end up with infinite recursion.</p>\\n<h3 id=\\\"bit-operations\\\">Bit operations</h3>\\n<p>ALWAYS put parenthesis around bit operations. Example: if ((a &amp; b) &gt; 0) {}  --&gt; otherwise compile error.</p>\\n\"}},{\"route\":\"arrays\",\"text\":\"Arrays\",\"children\":[{\"text\":\"Spiral\",\"slug\":\"arrays-spiral\",\"fullPath\":\"/learn/problems/arrays/arrays-spiral\",\"content\":{\"title\":\"Go through matrix in a spiral\",\"slug\":\"arrays-spiral\",\"contents\":\"<h3 id=\\\"complexity\\\">Complexity</h3>\\n<p>O(N) time + O(N) space for path.</p>\\n<h3 id=\\\"solution\\\">Solution</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static int[] spiral(int[][] matrix) {\\n        int col = matrix.length / 2;\\n        int row = matrix.length / 2;\\n        int[] path = new int[matrix.length * matrix.length];\\n        int pathIdx = 0;\\n        path[pathIdx] = matrix[col][row];\\n\\n        for (int subSize = 3; subSize &lt;= matrix.length; subSize += 2) {\\n\\n            // Go 1 step left.\\n            path[++pathIdx] = matrix[row][--col];\\n\\n            // Go down all the way.\\n            for (int i = 0; i &lt; subSize - 2; i++) {\\n                path[++pathIdx] = matrix[++row][col];\\n            }\\n\\n            // Go right all the way.\\n            for (int i = 0; i &lt; subSize - 1; i++) {\\n                path[++pathIdx] = matrix[row][++col];\\n            }\\n\\n            // Go up all the way.\\n            for (int i = 0; i &lt; subSize - 1; i++) {\\n                path[++pathIdx] = matrix[--row][col];\\n            }\\n\\n            // Go left all the way.\\n            for (int i = 0; i &lt; subSize - 1; i++) {\\n                path[++pathIdx] = matrix[row][--col];\\n            }\\n        }\\n        return path;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Sum of two\",\"slug\":\"arrays-sum-of-two\",\"fullPath\":\"/learn/problems/arrays/arrays-sum-of-two\",\"content\":{\"title\":\"Sum of two elements\",\"slug\":\"arrays-sum-of-two\",\"contents\":\"<h3 id=\\\"description\\\">Description</h3>\\n<p>Given an array of integers and a sum, return indices of the two numbers such that they add up to the sum.</p>\\n<h3 id=\\\"complexity\\\">Complexity</h3>\\n<p>O(N) time + O(N) space for the HashMap.</p>\\n<h3 id=\\\"solution\\\">Solution</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static Optional&amp;lt;int[]&amp;gt; findSumIndices(int[] numbers, int sum) {\\n        Map&amp;lt;Integer, Integer&amp;gt; numToIndex = new HashMap&lt;&gt;();\\n\\n        for (int i = 0; i &lt; numbers.length; i++) {\\n            int wanted = sum - numbers[i];\\n            if (numToIndex.containsKey(wanted)) {\\n                return Optional.of(new int[] { numToIndex.get(wanted), i });\\n            }\\n\\n            numToIndex.put(numbers[i], i);\\n        }\\n        return Optional.empty();\\n    }\\n}</code></pre>\\n\"}}],\"fullPath\":\"/learn/problems/arrays\"},{\"route\":\"hashtable\",\"text\":\"Hashtable\",\"children\":[{\"text\":\"Implement\",\"slug\":\"hashtable-implement\",\"fullPath\":\"/learn/problems/hashtable/hashtable-implement\",\"content\":{\"title\":\"Implement a hashtable\",\"slug\":\"hashtable-implement\",\"contents\":\"<h3 id=\\\"solution\\\">Solution</h3>\\n<p>Implement a generic Hashnode&lt;K, V&gt; class and store hashtable in a Hashnode&lt;K, V&gt;[]. Handle collisions by making linked lists (linear probing).</p>\\n<h3 id=\\\"discussion\\\">Discussion</h3>\\n<p><em>Linear vs. quadratic probing</em></p>\\n<p>a.  Linear probing leads to bigger clusters, and clusters reduce speed. A bad hash function can lead to\\nreally nasty clusters. However, with a good hash function which is good at avoiding collisions, linear\\nprobing is faster due to cache locality.</p>\\n<p>b.  Quadratic probing reduces cluster size, and this is good for speed, if you have problems with\\ncollisions. If you don\u2019t, then it\u2019s slower.</p>\\n<p><em>Power-of-two vs. prime size</em></p>\\n<p>a.  Prime table size spreads out the keys more evenly in the table which avoids clustering. Clustering makes\\nthe algorithm slow, especially with linear probing.</p>\\n<p>b.  Power-of-two table size does not spread out as good as a prime table with a bad hash function. However,\\na good one will spread well anyway, and we can avoid using modulo operations (expensive) and use a cheaper\\noperation (bit mask).</p>\\n<pre><code class=\\\"language-java\\\">/*\\n * A power-of-two hashtable using linear probing.\\n */\\npublic class HashTable&amp;lt;K, V&amp;gt; {\\n\\n    // 16 and 0.75 taken from real HashMap.\\n    private static final int INITIAL_CAPACITY = 16;\\n    private static final double LOAD_FACTOR = 0.75;\\n    private HashNode&amp;lt;K, V&amp;gt;[] table;\\n    private int size;\\n\\n    public HashTable() {\\n        table = new HashNode[INITIAL_CAPACITY];\\n        size = 0;\\n    }\\n\\n    public V get(K key) {\\n        int index = hashIndex(key);\\n\\n        for (Hashnode&amp;lt;K, V&amp;gt; node = table[index]; node != null; node = node.next) {\\n            if (key.equals(node.key)) {\\n                return node.value;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    public void put(K key, V value) {\\n        if (size &gt;= LOAD_FACTOR * table.length) {\\n            resize();\\n        }\\n\\n        int index = hashIndex(key);\\n        Hashnode&amp;lt;K, V&amp;gt; newNode = new Hashnode&amp;lt;&gt;(key, value);\\n\\n        if (table[index] == null) {\\n            table[index] = newNode;\\n        } else {\\n            Hashnode&amp;lt;K, V&amp;gt; node = table[index];\\n            while (node.next != null) {\\n                node = node.next;\\n            }\\n            node.next = newNode;\\n        }\\n        size++;\\n    }\\n\\n    private void resize() {\\n        HashNode[] newTable = new HashNode[table.length * 2];\\n\\n        for (int i = 0; i &lt; table.length; i++) {\\n            newTable[i] = table[i];\\n        }\\n\\n        table = newTable;\\n    }\\n\\n    private int hashIndex(K key) {\\n        int h = 0;\\n        h = key.hashCode() ^ (h &gt;&gt;&gt; 16);\\n\\n        // To find a bucket from a hash --&gt; use AND instead of modulo (expensive).\\n        return (table.length - 1) &amp; h;\\n    }\\n\\n    public int size() {\\n        return size;\\n    }\\n\\n    private class HashNode&amp;lt;K, V&amp;gt; {\\n\\n        private HashNode&amp;lt;K, V&amp;gt; next;\\n        private K key;\\n        private V value;\\n\\n        public HashNode(K key, V value) {\\n            this.key = key;\\n            this.value = value;\\n        }\\n    }\\n}</code></pre>\\n\"}}],\"fullPath\":\"/learn/problems/hashtable\"},{\"route\":\"linked-list\",\"text\":\"Linked list\",\"children\":[{\"text\":\"Cycle\",\"slug\":\"linked-list-cycle\",\"fullPath\":\"/learn/problems/linked-list/linked-list-cycle\",\"content\":{\"title\":\"Detect a cycle in a linked list\",\"slug\":\"linked-list-cycle\",\"contents\":\"<h3 id=\\\"okay-solution\\\">Okay solution</h3>\\n<p>Go through list one by one and check if already visited with a HashSet.</p>\\n<p>Complexity --&gt; O(N) time and O(N) space.</p>\\n<h3 id=\\\"best-solution\\\">Best solution</h3>\\n<p>Go through list with fast and slow runner. Slow runner takes one node at a time, fast takes two. If fast catches up with slow, it&#39;s a cycle. If fast comes to the end (null), it&#39;s not a cycle.</p>\\n<p>Complexity --&gt; O(N) time and O(1) space.</p>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean hasCycle(Node startNode) {\\n        Set&amp;lt;Integer&amp;gt; visited = new HashSet&lt;&gt;();\\n\\n        Node current = startNode;\\n        while (current.getNext() != null) {\\n            if (visited.contains(current.getId())) {\\n                return true;\\n            }\\n\\n            visited.add(current.getId());\\n            current = current.getNext();\\n        }\\n        return false;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean hasCycle(Node startNode) {\\n        Node slow = startNode;\\n        Node fast = startNode;\\n\\n        while (fast != null &amp;&amp; fast.getNext() != null) {\\n            slow = slow.getNext();\\n            fast = fast.getNext().getNext();\\n\\n            if (fast == slow) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Node {\\n\\n    private final Integer id;\\n    private Node next;\\n\\n    public Node(Integer id) {\\n        this.id = id;\\n    }\\n\\n    public Node getNext() {\\n        return next;\\n    }\\n\\n    public Integer getId() {\\n        return id;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Delete\",\"slug\":\"linked-list-delete\",\"fullPath\":\"/learn/problems/linked-list/linked-list-delete\",\"content\":{\"title\":\"Delete a node in a linked list\",\"slug\":\"linked-list-delete\",\"contents\":\"<h3 id=\\\"solution-1-root-is-given-\\\">Solution #1 (root is given)</h3>\\n<p>If root is given, we can loop to the previous node and set its next node to the node after the deleted node. The node will then be garbage collected.</p>\\n<p>Bad argument: Delete node doesn&#39;t exist.\\nBad argument: Delete node is the only node in the list.\\nSpecial case: Delete node is root.</p>\\n<h3 id=\\\"solution-2-root-is-not-given-\\\">Solution #2 (root is not given)</h3>\\n<p>We can only solve this with a more &quot;ugly&quot; solution - we&#39;ll swap Node values. If Node id&#39;s are final, we have to mess up the id&#39;s. If not final, we could swap both values and id&#39;s.</p>\\n<p>NOTE: we must assume given node is not the tail.</p>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static Node delete(Node root, Node node) {\\n\\n        // Special case: we want to delete root node.\\n        if (node == root) {\\n            if (root.getNext() == null) {\\n                throw new IllegalArgumentException(&quot;Can&#39;t delete only node in list.&quot;);\\n            }\\n            Node newRoot = root.getNext();\\n            root.setNext(null);\\n            return newRoot;\\n        }\\n\\n        // Other case: node is in middle or the last node.\\n        Node previous = root;\\n        while (previous != null &amp;&amp; previous.getNext() != node) {\\n            previous = previous.getNext();\\n        }\\n\\n        if (previous == null) {\\n            throw new IllegalArgumentException(&quot;Given node does not exist in list.&quot;);\\n        }\\n\\n        // Node will be garbage collected.\\n        previous.setNext(node.getNext());\\n        return root;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    /**\\n     * Only handles nodes that aren&#39;t the tail.\\n     * Also messes up id&#39;s since it only swaps values, not actual nodes.\\n     */\\n    public static void delete(Node node) {\\n        if (node == null || node.getNext() == null) {\\n            throw new IllegalArgumentException(&quot;Bad argument.&quot;);\\n        }\\n\\n        node.setValue(node.getNext().getValue());\\n        node.setNext(node.getNext().getNext());\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Node {\\n\\n    private final int id;\\n    private Node next;\\n    private int value;\\n\\n    public Node(int id, int value) {\\n        this.id = id;\\n        this.value = value;\\n    }\\n\\n    public Node getNext() {\\n        return next;\\n    }\\n\\n    public void setNext(Node next) {\\n        this.next = next;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public int getValue() {\\n        return value;\\n    }\\n\\n    public void setValue(int value) {\\n        this.value = value;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Merge\",\"slug\":\"linked-list-merge\",\"fullPath\":\"/learn/problems/linked-list/linked-list-merge\",\"content\":{\"title\":\"Merge two sorted linked lists\",\"slug\":\"linked-list-merge\",\"contents\":\"<h3 id=\\\"solution-1\\\">Solution #1</h3>\\n<p>Create a dummy node to keep track of start of merged list. Go through both and merge from small to large.</p>\\n<h3 id=\\\"solution-2\\\">Solution #2</h3>\\n<p>Don&#39;t use a dummy and do an initialization step to keep track of return node.</p>\\n<h3 id=\\\"complexity\\\">Complexity</h3>\\n<p>Worst case is O(N) time (N = total nr of nodes) and best case O(1) (when first list has length 1 and second length N-1 - then we just &quot;hang&quot; them onto each other).</p>\\n<p>Space is O(1).</p>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static Node merge(Node first, Node second) {\\n        if (first == null) {\\n            return second;\\n        } else if (second == null) {\\n            return first;\\n        }\\n\\n        // Create dummy node to avoid initializing merged list.\\n        Node dummy = new Node(0, 0);\\n        Node merged = dummy;\\n\\n        // Take the smallest node from first/second while none is null.\\n        while (first != null &amp;&amp; second != null) {\\n            if (first.getValue() &lt; second.getValue()) {\\n                merged.setNext(first);\\n                first = first.getNext();\\n            } else {\\n                merged.setNext(second);\\n                second = second.getNext();\\n        }\\n\\n            merged = merged.getNext();\\n        }\\n\\n        // Merge the left over nodes.\\n        Node  leftOver = first == null ? second : first;\\n        merged.setNext(leftOver);\\n\\n        return dummy.getNext();\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static Node merge(Node first, Node second) {\\n        if (first == null) {\\n            return second;\\n        } else if (second == null) {\\n            return first;\\n        }\\n\\n        Node merged;\\n        Node mergedStart;\\n\\n        // Initialize the merged list.\\n        if (first.getValue() &lt; second.getValue()) {\\n            merged = first;\\n            first = first.getNext();\\n        } else {\\n            merged = second;\\n            second = second.getNext();\\n        }\\n\\n        mergedStart = merged;\\n\\n        // Take the smallest node from first/second while none is null.\\n        while (first != null &amp;&amp; second != null) {\\n            if (first.getValue() &lt; second.getValue()) {\\n                merged.setNext(first);\\n                first = first.getNext();\\n            } else {\\n                merged.setNext(second);\\n                second = second.getNext();\\n            }\\n\\n            merged = merged.getNext();\\n        }\\n\\n        // Merge the left over nodes.\\n        Node  leftOver = first == null ? second : first;\\n        merged.setNext(leftOver);\\n\\n        return mergedStart;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Node {\\n\\n    private final int id;\\n    private Node next;\\n    private int value;\\n\\n    public Node(int id, int value) {\\n        this.id = id;\\n        this.value = value;\\n    }\\n\\n    public Node getNext() {\\n        return next;\\n    }\\n\\n    public void setNext(Node next) {\\n        this.next = next;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public int getValue() {\\n        return value;\\n    }\\n\\n    public void setValue(int value) {\\n        this.value = value;\\n    }\\n}</code></pre>\\n\"}}],\"fullPath\":\"/learn/problems/linked-list\"},{\"route\":\"strings\",\"text\":\"Strings\",\"children\":[{\"text\":\"Anagram\",\"slug\":\"strings-anagram\",\"fullPath\":\"/learn/problems/strings/strings-anagram\",\"content\":{\"title\":\"Anagram\",\"slug\":\"strings-anagram\",\"contents\":\"<h3 id=\\\"description\\\">Description</h3>\\n<p>Write a function to determine if one String is an anagram of another (anagram = shuffled chars).</p>\\n<h3 id=\\\"solution-1\\\">Solution #1</h3>\\n<p>Use some sort (quicksort, mergesort etc.) and compare.</p>\\n<p>Complexity --&gt; O(2 * N log N + N) =  O(N log N)  time and O(1) space.</p>\\n<h3 id=\\\"solution-2\\\">Solution #2</h3>\\n<p>Compare both Strings against an array of found chars. Must assume a low number of chars (like ASCII), otherwise too much space usage.</p>\\n<p>Complexity --&gt; O(2N) = O(N) time and O(1) space.</p>\\n<h3 id=\\\"solution\\\">Solution</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean isAnagram(char[] first, char[] second) {\\n        if (first.length != second.length || first.length == 0) {\\n            return false;\\n        }\\n\\n        // O(2 * N log N).\\n        Arrays.sort(first);\\n        Arrays.sort(second);\\n\\n        // O(N).\\n        for (int i = 0; i &lt; first.length; i++) {\\n            if (first[i] != second[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean isAnagram(char[] first, char[] second) {\\n        if (first.length != second.length || first.length == 0) {\\n            return false;\\n        }\\n\\n        int[] charCounts = new int[256];\\n        int nrOfUniqueChars = 0;\\n        int completedChars = 0;\\n\\n        // Go through first array --&gt; O(N).\\n        for (int i = 0; i &lt; first.length; i++) {\\n            if (charCounts[first[i]] == 0) {\\n                nrOfUniqueChars++;\\n            }\\n\\n            charCounts[first[i]]++;\\n        }\\n\\n        // Check second against first array --&gt; O(N).\\n        for (int i = 0; i &lt; second.length; i++) {\\n\\n            // Not an anagram if we find a char in second which isn&#39;t present in first.\\n            if (charCounts[second[i]] == 0) {\\n                return false;\\n            }\\n\\n            // For every found char, the count is reduced.\\n            charCounts[second[i]]--;\\n\\n            // We&#39;re done if all unique chars have been found.\\n            if (charCounts[second[i]] == 0) {\\n                completedChars++;\\n                if (completedChars == nrOfUniqueChars) {\\n                    return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Palindrome\",\"slug\":\"strings-palindrome\",\"fullPath\":\"/learn/problems/strings/strings-palindrome\",\"content\":{\"title\":\"Palindrome\",\"slug\":\"strings-palindrome\",\"contents\":\"<h3 id=\\\"description\\\">Description</h3>\\n<p>Write a function to determine if one String is a palindrome (forward = backwards).</p>\\n<h2 id=\\\"solution\\\">Solution</h2>\\n<p>Two pointers - one goes forward and one backwards to the middle.</p>\\n<pre><code class=\\\"language-java\\\">public static boolean isPalindrome(String input) {\\n    int rightIdx = input.length() - 1;\\n\\n    for (int leftIdx = 0; leftIdx &lt; input.length() / 2; leftIdx++) {\\n        if (input.charAt(leftIdx) != input.charAt(rightIdx)) {\\n            return false;\\n        }\\n        rightIdx--;\\n    }\\n\\n    return true;\\n}</code></pre>\\n\"}},{\"text\":\"Unique chars\",\"slug\":\"strings-unique-chars\",\"fullPath\":\"/learn/problems/strings/strings-unique-chars\",\"content\":{\"title\":\"Unique characters in a String\",\"slug\":\"strings-unique-chars\",\"contents\":\"<h3 id=\\\"description\\\">Description</h3>\\n<p>Write a function to determine if a String has all unique characters.</p>\\n<h3 id=\\\"solution-1\\\">Solution #1</h3>\\n<p>Assume ASCII = 256 chars. Store in boolean array. Go through entire String.</p>\\n<p>Complexity --&gt; O(N) time and O(1) space.</p>\\n<h3 id=\\\"solution-2\\\">Solution #2</h3>\\n<p>Assume only [a-z] = 26 chars. Store in an int (32 bits). Go through entire String.</p>\\n<p>Complexity --&gt; O(N) time and O(1) space.</p>\\n<h3 id=\\\"solution-3\\\">Solution #3</h3>\\n<p>Assume any value of Java char = 16 bits --&gt; 2^16 different values. Store in a BitSet with 2^16 = 65536. Go through entire String.</p>\\n<p>Complexity --&gt; O(N) time and O(1) space.</p>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean uniqueChars(String string) {\\n        if (string.length() &gt; 256) {\\n            return false;\\n        }\\n\\n        boolean[] foundChars = new boolean[256];\\n\\n        for (char character : string.toCharArray()) {\\n            if (foundChars[character]) {\\n                return false;\\n            }\\n\\n            foundChars[character] = true;\\n        }\\n\\n        return true;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean uniqueChars(String string) {\\n        if (string.length() &gt; 26) {\\n            return false;\\n        }\\n\\n        int foundChars = 0;\\n\\n        for (char character : string.toCharArray()) {\\n            if ((foundChars &amp; (1 &lt;&lt; character)) &gt; 0) {\\n                return false;\\n            }\\n\\n            foundChars = foundChars | (1 &lt;&lt; character);\\n        }\\n\\n        return true;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static boolean uniqueChars(String string) {\\n        int assumedNrOfPossibleChars = 1 &lt;&lt; 16; // 2^16\\n        if (string.length() &gt; assumedNrOfPossibleChars) {\\n            return false;\\n        }\\n\\n        BitSet charset = new BitSet(assumedNrOfPossibleChars);\\n        for (char character : string.toCharArray()) {\\n            if (charset.get(character)) {\\n                return false;\\n            }\\n            charset.set(character);\\n        }\\n        return true;\\n    }\\n}</code></pre>\\n\"}}],\"fullPath\":\"/learn/problems/strings\"},{\"route\":\"trees\",\"text\":\"Trees\",\"children\":[{\"text\":\"BST balanced\",\"slug\":\"trees-bst-balanced\",\"fullPath\":\"/learn/problems/trees/trees-bst-balanced\",\"content\":{\"title\":\"Is the BST balanced?\",\"slug\":\"trees-bst-balanced\",\"contents\":\"<p>More information is coming!</p>\\n\"}}],\"fullPath\":\"/learn/problems/trees\"}],\"fullPath\":\"/learn/problems\"},{\"route\":\"algorithms\",\"text\":\"Algorithms\",\"children\":[{\"text\":\"A-star\",\"slug\":\"a-star\",\"fullPath\":\"/learn/algorithms/a-star\",\"content\":{\"title\":\"A-star\",\"slug\":\"a-star\",\"what\":\"More general case of Dijkstra's. Finds the (approximated) shortest path between two nodes. Uses a heuristic h computing the approximated distance left to the goal. In Dijkstra's, h = 0 for all nodes.\",\"contents\":\"\"}},{\"text\":\"BFS graph\",\"slug\":\"bfs-graph\",\"fullPath\":\"/learn/algorithms/bfs-graph\",\"content\":{\"title\":\"Breadth First Search (BFS) for graphs\",\"slug\":\"bfs-graph\",\"worstTime\":\"O(V + E), if we're searching for something, every edge and every vertex has to be looked at.\",\"contents\":\"<h3 id=\\\"difference-from-tree\\\">Difference from Tree</h3>\\n<p>Must also keep track of visited nodes to avoid going in circles or visiting the same node multiple times.</p>\\n<h3 id=\\\"when-to-use-bfs-over-dfs\\\">When to use BFS over DFS</h3>\\n<ol>\\n<li>When we know solution(s) is close to root.</li>\\n<li>When we want optimal/closest solution.</li>\\n<li>If tree is very deep &amp; solutions rare, BFS could be quicker than DFS.</li>\\n</ol>\\n\"}},{\"text\":\"DFS graph\",\"slug\":\"dfs-graph\",\"fullPath\":\"/learn/algorithms/dfs-graph\",\"content\":{\"title\":\"Depth First Search (DFS) for graphs\",\"slug\":\"dfs-graph\",\"worstTime\":\"O(V + E), if we're searching for something, every edge and every vertex has to be looked at.\",\"contents\":\"<h3 id=\\\"difference-from-tree\\\">Difference from Tree</h3>\\n<p>Must also keep track of visited nodes to avoid going in circles or visiting the same node multiple times.</p>\\n<h3 id=\\\"when-to-use-dfs-over-bfs\\\">When to use DFS over BFS</h3>\\n<ol>\\n<li>When there are many neighbors/branching factor is high --&gt; then BFS takes up much space &amp; DFS is better.</li>\\n<li>When there are many solutions but they are deep in the tree/graph.</li>\\n<li>When it&#39;s okay that we get a sub-optimal solution (not guaranteed shortest from source.</li>\\n</ol>\\n\"}},{\"text\":\"Dijkstras\",\"slug\":\"dijkstras\",\"fullPath\":\"/learn/algorithms/dijkstras\",\"content\":{\"title\":\"Dijkstra's algorithm\",\"slug\":\"dijkstras\",\"what\":\"Finds the shortest path to all vertices in a Directed Weighted Graph (easily modified for undirected) given a start vertex.\",\"how\":\"Given a start vertex. | Put start vertex in queue (min-heap). | While queue is not empty... | Poll the queue for the current vertex. | Go through its adjacency list (list of edges). | For all edges, find neighbors and evaluate cost to get there from current. | If lower than current min, update min-heap with the new values.\",\"averageTime\":\"O(E log V) with a binary heap, because we go through all vertices and do poll() --> O(V log V). In the inner loop we go though all edges and possibly do a decreaseKey-operation --> O(E log V). Final complexity is O(V log V) + O(E log V) = O(E log V). With a fibonacci heap it's O(E + V log V).\",\"space\":\"Adjacency list --> O(V + E). Adjacency matrix --> O(V^2).\",\"contents\":\"<h3 id=\\\"constraints\\\">Constraints</h3>\\n<p>Original/simple version doesn&#39;t work with negative weights (but the below does). However, it doesn&#39;t work if we have cycles with negative sum (will loop forever). The Bellman\u2013Ford algorithm can be used in such cases.</p>\\n<h3 id=\\\"some-information\\\">Some information</h3>\\n<p>Original algorithm doesn&#39;t use a min-priority queue --&gt; O(V^2). A min-priority queue is an optimization (even faster if it&#39;s a Fibonacci heap).</p>\\n<p>This is asymptotically the fastest known single-source shortest-path algorithm for directed graphs with unbounded, non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can be improved further.</p>\\n<h3 id=\\\"different-implementations\\\">Different implementations</h3>\\n<p>There are different ways to represent a graph.</p>\\n<ul>\\n<li>Adjacency Matrix is preferable when we expect the graph to be dense.</li>\\n<li>Adjacency List is preferable when we expect the graph to be sparse.</li>\\n</ul>\\n<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    /**\\n     * Update the min-distances and predecessors on all vertices given a certain source vertex.\\n     */\\n    public static void updateDijkstraDistances(Vertex source) {\\n        source.setMinDistance(0);\\n        PriorityQueue&amp;lt;Vertex&amp;gt; vertexQueue = new PriorityQueue&lt;&gt;();\\n        vertexQueue.add(source);\\n\\n        while (!vertexQueue.isEmpty()) {\\n\\n            // Get and remove the current prioritized vertex &amp; visit all of its edges.\\n            Vertex current = vertexQueue.poll();\\n\\n            for (Edge edge : current.getEdges()) {\\n                Vertex neighbor = edge.getDestination();\\n                double distanceToNeighbor = current.getMinDistance() + edge.getCost();\\n\\n                // If we found a new min distance to the neighbor, update it. Note: remove\\n                // is O(V) and add is O(log V) so the optimized Dijkstra should use a\\n                // decreaseKey-operation with O(log V) time, but I&#39;m using this for simplicity.\\n                if (distanceToNeighbor &lt; neighbor.getMinDistance()) {\\n                    vertexQueue.remove(neighbor);\\n                    neighbor.setMinDistance(distanceToNeighbor);\\n                    neighbor.setPredecessor(current);\\n                    vertexQueue.add(neighbor);\\n                }\\n            }\\n        }\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">\\npublic class Graph {\\n\\n    private Vertex[] vertices;\\n\\n    public Graph(Vertex[] vertices) {\\n        this.vertices = vertices;\\n    }\\n\\n    public Vertex[] getVertices() {\\n        return vertices;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Vertex {\\n\\n    // Properties representing the vertex itself.\\n    private int id;\\n    private Edge[] adjacencyList;\\n\\n    // Properties updated by the Dijkstra algorithm depending on a given source vertex.\\n    private double minDistance = Double.POSITIVE_INFINITY;\\n    private Vertex predecessor;\\n\\n    public Vertex(int id) {\\n        this.id = id;\\n    }\\n\\n    // This is needed in order to put this object in a priority queue.\\n    public int compareTo(Vertex other) {\\n        Double.compare(minDistance, other.minDistance);\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public Edge[] getEdges() {\\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\\n    }\\n\\n    public void setEdges(Edge[] adjacencyList) {\\n        this.adjacencyList = adjacencyList;\\n    }\\n\\n    public double getMinDistance() {\\n        return minDistance;\\n    }\\n\\n    public Vertex getPredecessor() {\\n        return predecessor;\\n    }\\n\\n    public void setMinDistance(double minDistance) {\\n        this.minDistance = minDistance;\\n    }\\n\\n    public void setPredecessor(Vertex predecessor) {\\n        this.predecessor = predecessor;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Edge {\\n\\n    private Vertex destination;\\n    private double weight;\\n\\n    public Edge(Vertex destination, double weight) {\\n        this.destination = destination;\\n        this.weight = weight;\\n    }\\n\\n    public Vertex getDestination() {\\n        return destination;\\n    }\\n\\n    public double getWeight() {\\n        return weight;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"BST traversal\",\"slug\":\"bst-traversal\",\"fullPath\":\"/learn/algorithms/bst-traversal\",\"content\":{\"title\":\"Binary search tree traversal\",\"slug\":\"bst-traversal\",\"what\":\"There is pre-order, in-order and post-order traversal.\",\"how\":\"Recursively go through a binary tree. We have current, left and right node. | Pre-order; current is \\\"pre\\\"/before --> current, left, right. | In-order; current is \\\"in\\\"/middle --> left, current, right. | Post-order; current is \\\"post\\\"/after --> left, right, current.\",\"contents\":\"<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    public static void preOrderTraversal(Node node) {\\n        if (node != null) {\\n            System.out.println(node); // Current\\n            inOrderTraversal(node.getLeft()); // Left\\n            inOrderTraversal(node.getRight()); // Right\\n        }\\n    }\\n\\n    public static void inOrderTraversal(Node node) {\\n        if (node != null) {\\n            inOrderTraversal(node.getLeft()); // Left\\n            System.out.println(node); // Current\\n            inOrderTraversal(node.getRight()); // Right\\n        }\\n    }\\n\\n    public static void preOrderTraversal(Node node) {\\n        if (node != null) {\\n            inOrderTraversal(node.getLeft()); // Left\\n            inOrderTraversal(node.getRight()); // Right\\n            System.out.println(node); // Current\\n        }\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Topological sort\",\"slug\":\"topological-sort\",\"fullPath\":\"/learn/algorithms/topological-sort\",\"content\":{\"title\":\"Topological sort (graphs)\",\"slug\":\"topological-sort\",\"what\":\"Ordering for DAG's. Every parent must come before its child. Can be multiple for same graph.\",\"how\":\"Kind of like DFS but with extra stack (recursion stack + stack).\",\"averageTime\":\"Same as DFS --> O(E + V).\",\"contents\":\"<h3 id=\\\"example-applications\\\">Example applications</h3>\\n<ol>\\n<li>Scheduling jobs with dependencies given as graph.</li>\\n<li>Finding order of compilation tasks to perform in makefiles.</li>\\n</ol>\\n<h3 id=\\\"implementation\\\">Implementation</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    /*\\n     * Topological sort for one entire DAG.\\n     */\\n    public static void topologicalSort(Graph graph) {\\n        Stack&amp;lt;Vertex&amp;gt; stack = new Stack&lt;&gt;();\\n        Set&amp;lt;Integer&amp;gt; visited = new HashSet&lt;&gt;();\\n\\n        // Go through entire graph.\\n        for (Vertex current : graph.getVertices()) {\\n            if (!visited.contains(current.getId())) {\\n                topologicalSort(current, stack, visited);\\n            }\\n        }\\n\\n        // Print the stack.\\n        while (!stack.isEmpty()) {\\n            System.out.println(stack.pop().getId());\\n        }\\n    }\\n\\n    /*\\n     * Recursive part of topological sort.\\n     */\\n    private static void topologicalSort(Vertex current, Stack&amp;lt;Vertex&amp;gt; stack, Set&amp;lt;Integer&amp;gt; visited) {\\n        visited.add(current.getId());\\n\\n        for (Edge edge : current.getEdges()) {\\n            Vertex neighbor = edge.getDestination();\\n            if (!visited.contains(neighbor.getId())) {\\n                topologicalSort(neighbor, stack, visited);\\n            }\\n        }\\n\\n        stack.push(current);\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Graph {\\n\\n    private Vertex[] vertices;\\n\\n    public Graph(Vertex[] vertices) {\\n        this.vertices = vertices;\\n    }\\n\\n    public Vertex[] getVertices() {\\n        return vertices;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Vertex {\\n\\n    private int id;\\n    private Edge[] adjacencyList;\\n\\n    public Vertex(int id) {\\n        this.id = id;\\n    }\\n\\n    public int getId() {\\n        return id;\\n    }\\n\\n    public Edge[] getEdges() {\\n        return adjacencyList == null ? new Edge[0] : adjacencyList;\\n    }\\n\\n    public void setEdges(Edge[] adjacencyList) {\\n        this.adjacencyList = adjacencyList;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Edge {\\n\\n    private Vertex destination;\\n    private double weight;\\n\\n    public Edge(Vertex destination, double weight) {\\n        this.destination = destination;\\n        this.weight = weight;\\n    }\\n\\n    public Vertex getDestination() {\\n        return destination;\\n    }\\n\\n    public double getWeight() {\\n        return weight;\\n    }\\n}</code></pre>\\n\"}}],\"fullPath\":\"/learn/algorithms\"},{\"route\":\"concepts\",\"text\":\"Concepts\",\"children\":[{\"text\":\"Backtracking\",\"slug\":\"backtracking\",\"fullPath\":\"/learn/concepts/backtracking\",\"content\":{\"title\":\"Backtracking\",\"slug\":\"backtracking\",\"what\":\"Using recursion (or stack) to examine all possible solutions/paths in a problem. If you reach a dead end, you backtrack (go back) to a previous state.\",\"contents\":\"<h3 id=\\\"example-find-a-word-in-a-matrix\\\">Example: find a word in a matrix</h3>\\n<p>Let&#39;s say we have a matrix with chars and we want to find a certain word. A backtracking algorithm could step through\\nthe matrix and look for paths, and if the path comes to an end, it backtracks to look for other possibilities.</p>\\n<pre><code class=\\\"language-java\\\">public class WordSearchMatrix {\\n\\n    private char[][] matrix;\\n    private int N;\\n    private char[][] solution;\\n    private int path;\\n\\n    public WordSearchMatrix(char[][] matrix) {\\n        this.matrix = matrix;\\n        this.N = matrix.length;\\n    }\\n\\n    public Optional&amp;lt;int[][]&amp;gt; searchWord(String searchWord) {\\n        solution = new char[N][N];\\n        path = 1;\\n        word = searchWord;\\n\\n        // Go through entire matrix.\\n        for (int row = 0; row &lt; N; row++) {\\n            for (int col = 0; col &lt; N; col++) {\\n\\n                // Note: charIndex is always 0 here because at this step we&#39;re always at the beginning\\n                // and findSolution does the recursive part.\\n                if (findSolution(int row, int col, 0)) {\\n                    return solution;\\n                }\\n            }\\n        }\\n        return Optional.empty();\\n    }\\n\\n    private boolean findSolution(int row, int col, int charIndex) {\\n\\n        // If current cell is already visited or doesn&#39;t contain the correct char, then no solution here.\\n        if (solution[row][col] != 0 || matrix[row][col] != word.charAt(charIndex)) {\\n            return false;\\n        }\\n\\n        // If we&#39;re at the last charIndex and it contains the correct char, we have a solution.\\n        if (charIndex == word.length() - 1) {\\n            solution[row][col] = path++;\\n            return true;\\n        }\\n\\n        // We found a correct char. Let&#39;s continue.\\n        charIndex++;\\n        solution[row][col] = path++;\\n\\n        // Go down.\\n        if (row + 1 &lt; N &amp;&amp; findSolution(row + 1, col, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go up.\\n        if (row - 1 &gt;= 0 &amp;&amp; search(row - 1, col, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go right.\\n        if (col + 1 &lt; N &amp;&amp; search(row, col + 1, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go left.\\n        if (col - 1 &gt;= 0 &amp;&amp; search(row, col - 1, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go diagonally up right.\\n        if (row - 1 &gt;= 0 &amp;&amp; col + 1 &lt; N &amp;&amp; search(row - 1, col + 1, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go diagonally up left.\\n        if (row - 1 &gt;= 0 &amp;&amp; col - 1 &gt;= 0 &amp;&amp; search(row - 1, col - 1, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go diagonally down left.\\n        if (row + 1 &lt; N &amp;&amp; col - 1 &gt;= 0 &amp;&amp; search(row + 1, col - 1, charIndex)) {\\n            return true;\\n        }\\n\\n        // Go diagonally down right.\\n        if (row + 1 &lt; N &amp;&amp; col + 1 &lt; N &amp;&amp; search(row + 1, col + 1, charIndex)) {\\n            return true;\\n        }\\n\\n        // If none of the above steps worked out --&gt; BACKTRACK.\\n        path--;\\n        solution[row][col] = 0;\\n        return false;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Greedy\",\"slug\":\"greedy\",\"fullPath\":\"/learn/concepts/greedy\",\"content\":{\"title\":\"Greedy\",\"slug\":\"greedy\",\"contents\":\"<p>More information coming!</p>\\n\"}},{\"text\":\"Memoization\",\"slug\":\"memoization\",\"fullPath\":\"/learn/concepts/memoization\",\"content\":{\"title\":\"Memoization\",\"slug\":\"memoization\",\"what\":\"DP --> Solve problems recursively when computations of subproblems overlap. Memoization --> Memorizing sub problems to avoid recomputing them.\",\"contents\":\"<h3 id=\\\"example-calculate-n-th-fibonacci-number\\\">Example: calculate n&#39;th fibonacci number</h3>\\n<p>To calculate fibonacci(n) we need fibonacci(n-1) + fibonacci(n-2) --&gt; leads to a lot of unnecessary recomputing.\\nWe must use memoization! If we try to compute the 50th fibonacci nr with the slow and the fast one, we see a\\nhuge difference in running time.</p>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n    public static int fibonacci(int n) {\\n        return n &lt; 2 ? n : fibonacci(n-1) + fibonacci(n-2);\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\n    private static Map&amp;lt;Integer, Long&amp;gt; cache = new HashMap&lt;&gt;();\\n\\n    public static long fibonacci(int n) {\\n        if (n &lt; 2) {\\n            return n;\\n        }\\n\\n        Long value = cache.get(n);\\n\\n        if (value == null) {\\n            value = fibonacci(n-1) + fibonacci(n-2);\\n            cache.put(n, value);\\n        }\\n\\n        return value;\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Recursion\",\"slug\":\"recursion\",\"fullPath\":\"/learn/concepts/recursion\",\"content\":{\"title\":\"Recursion\",\"slug\":\"recursion\",\"what\":\"A function being defined is applied within its own definition. Or in other words, recursion is when a function calls itself.\",\"contents\":\"<h3 id=\\\"good\\\">Good</h3>\\n<p>Elegant, simple. Some languages are well suited for it. Instead of the call stack being a problem, you can\\nactually take advantage of it in a clever way by doing iterative branching --&gt; for example call a function\\nmultiple times in same loop but with different parameters, that&#39;s branching. If you try an iterative solution,\\nyou often need a stack and you re-invent the wheel.</p>\\n<h3 id=\\\"bad\\\">Bad</h3>\\n<p>In most languages it&#39;s bad, because of Stack Overflow issues + it also takes some time to copy stuff to stack etc.\\nso it will run slower due to function call overhead.</p>\\n<h3 id=\\\"time-complexity\\\">Time Complexity</h3>\\n<ul>\\n<li>Simple way: compute by reasoning about how many times function will be called.</li>\\n<li>More difficult cases: use Master Theorem or guess and use induction. Example: recursive fibonacci --&gt; T(n-1) + T(n-2) + T(1) --&gt; O(fib(n)) ~= O(1.6^n)</li>\\n</ul>\\n<h3 id=\\\"examples-of-time-complexity\\\">Examples of Time Complexity</h3>\\n<pre><code class=\\\"language-java\\\">\\n// O(N/3) = O(N)\\nint function1(int n) {\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        return 1 + recursiveFun1(n-3);\\n    }\\n}\\n\\n// O(log4 N) = O(log N)\\nint function2(int n) {\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        return 1 + function2(n/4);\\n    }\\n}\\n\\n// O(2^N) --&gt; Think of this as a binary tree with height N.\\nint function3(int n) {\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        function3(n - 1);\\n        function3(n - 1);\\n    }\\n}\\n\\n// ???\\nint function4(int n) {\\n    for (i = 0; i &lt; n; i += 2) {\\n        System.out.println(&quot;Hello&quot;);\\n    }\\n\\n    if (n &lt;= 0) {\\n        return 1;\\n    } else {\\n        return 1 + function4(n-5);\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Tabulation\",\"slug\":\"tabulation\",\"fullPath\":\"/learn/concepts/tabulation\",\"content\":{\"title\":\"Tabulation\",\"slug\":\"tabulation\",\"what\":\"A method for constructing universal families of hash functions by combining table lookup with exclusive OR operations.\",\"contents\":\"<p>More information is coming!</p>\\n\"}}],\"fullPath\":\"/learn/concepts\"},{\"route\":\"languages\",\"text\":\"Languages\",\"children\":[{\"route\":\"java\",\"text\":\"Java\",\"children\":[{\"text\":\"Datatypes\",\"slug\":\"java-datatypes\",\"fullPath\":\"/learn/languages/java/java-datatypes\",\"content\":{\"title\":\"Java datatypes\",\"slug\":\"java-datatypes\",\"contents\":\"<h3 id=\\\"byte\\\">Byte</h3>\\n<ul>\\n<li>8 bit integer</li>\\n<li>Signed, two&#39;s complement</li>\\n<li>Min value: -2^7</li>\\n<li>Max value: 2^7 - 1</li>\\n<li>Usage #1: when you want to save space (e.g. you have a huge array)</li>\\n<li>Usage #2: code understanding (reader understands range is limited)</li>\\n</ul>\\n<h3 id=\\\"short\\\">Short</h3>\\n<ul>\\n<li>16 bit integer</li>\\n<li>Signed, two&#39;s complement</li>\\n<li>Min value: -2^15</li>\\n<li>Max value: 2^15 - 1</li>\\n<li>Usage: same as byte</li>\\n</ul>\\n<h3 id=\\\"int\\\">Int</h3>\\n<ul>\\n<li>32 bit integer</li>\\n<li>Signed, two&#39;s complement (last bit is a sign bit)</li>\\n<li>Min value: -2^31</li>\\n<li>Max value: 2^31 - 1 = 2147483647</li>\\n</ul>\\n<h3 id=\\\"long\\\">Long</h3>\\n<ul>\\n<li>64 bit integer</li>\\n<li>Signed, two&#39;s complement</li>\\n<li>Min value: -2^63</li>\\n<li>Max value: 2^63 - 1</li>\\n<li>Usage: when you need a wider range than int</li>\\n<li>Initialize: 0L</li>\\n</ul>\\n<h3 id=\\\"float\\\">Float</h3>\\n<ul>\\n<li>32 bit floating point</li>\\n<li>Use instead of double if you wan&#39;t to save memory</li>\\n<li>Shouldn&#39;t be used for precise values, like currency.</li>\\n<li>Initialize: 0.0f</li>\\n</ul>\\n<h3 id=\\\"double\\\">Double</h3>\\n<ul>\\n<li>64 bit floating point</li>\\n<li>Shouldn&#39;t be used for precise values, like currency.</li>\\n<li>Initialize: 0.0d</li>\\n</ul>\\n<h3 id=\\\"char\\\">Char</h3>\\n<ul>\\n<li>16 bit character (UTF-16)</li>\\n<li>Initialize: &#39;hello&#39;</li>\\n</ul>\\n\"}},{\"text\":\"Lambdas/closures\",\"slug\":\"java-lambdas-closures\",\"fullPath\":\"/learn/languages/java/java-lambdas-closures\",\"content\":{\"title\":\"Java lambdas vs. closures\",\"slug\":\"java-lambdas-closures\",\"contents\":\"<h3 id=\\\"lambdas-vs-closures\\\">Lambdas vs. closures</h3>\\n<p>A closure = function that keeps a private state and can be passed around. For example, JavaScript has closures. Lambda = function that can be created at runtime and can change a private state.</p>\\n<p>Difference = lambdas can&#39;t modify variables defined in the outer closure (such code gives compile errors). A workaround is to wrap variables you want to modify in a class. However, if you have concurrency there&#39;s an issue with the modifiable shared state.</p>\\n<h3 id=\\\"example-of-compile-error-variable-used-in-lambda-expression-should-be-final-or-effectively-final-\\\">Example of compile error (&quot;Variable used in lambda expression should be final or effectively final&quot;):</h3>\\n<pre><code class=\\\"language-java\\\">public class Codeyay {\\n\\nprivate static Function&amp;lt;Integer, Integer&amp;gt; makeFunction() {\\n    int n = 0; // Outside the lambda scope.\\n\\n    return arg -&gt; {\\n        System.out.print(n + &quot; &quot; + arg + &quot;: &quot;);\\n        arg += 1;\\n        n += arg; // This does not compile!\\n        return n + arg;\\n        };\\n    }\\n}</code></pre>\\n<h3 id=\\\"example-of-workaround-which-does-compile-\\\">Example of workaround which does compile:</h3>\\n<pre><code class=\\\"language-java\\\">class MyInt {\\n    int n = 0;\\n}\\n\\npublic class Codeyay {\\n\\n    private static Function&amp;lt;Integer, Integer&amp;gt; makeFunction() {\\n        final MyInt myInt = new MyInt(); // Outside the lambda scope.\\n\\n        return arg -&gt; {\\n            System.out.print(myInt.n + &quot; &quot; + arg + &quot;: &quot;);\\n            arg += 1;\\n            myInt.n += arg; // This is fine.\\n            return myInt.n + arg;\\n        };\\n    }\\n\\n    public static void tryLambdas() {\\n        Function&amp;lt;Integer, Integer&amp;gt; x = makeFunction();\\n        Function&amp;lt;Integer, Integer&amp;gt; y = makeFunction();\\n\\n        for (int i = 0; i &lt; 5; i++) {\\n            System.out.println(x.apply(i));\\n        }\\n\\n        for (int i = 0; i &lt; 3; i++) {\\n            System.out.println(y.apply(i));\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        tryLambdas();\\n    }\\n}</code></pre>\\n\"}},{\"text\":\"Pros/cons\",\"slug\":\"java-pros-cons\",\"fullPath\":\"/learn/languages/java/java-pros-cons\",\"content\":{\"title\":\"Java pros and cons\",\"slug\":\"java-pros-cons\",\"contents\":\"<h3 id=\\\"pros\\\">Pros</h3>\\n<ol>\\n<li>Scalable.</li>\\n<li>Much support.</li>\\n<li>Garbage collection.</li>\\n<li>Type check.</li>\\n<li>Often &quot;forces&quot; a more structured code design.</li>\\n<li>Because of type check etc. --&gt; often easy to debug.</li>\\n<li>Often self-explanatory. In Python we often need a lot of comments to explain the code, while in Java\\nyou only need comments for parts that might be extra difficult to understand.</li>\\n</ol>\\n<h3 id=\\\"cons\\\">Cons</h3>\\n<ol>\\n<li>Simple things = much code.</li>\\n<li>Boolean, Integer etc. can be null, which can be confusing.</li>\\n<li>Forced to use primitive wrappers if we want to put them in List, Map etc.. and\\nmemory size of wrapper is bigger than the size of the primitive.</li>\\n<li>Doesn&#39;t have closures, however lambdas are pretty close.</li>\\n<li>People complain about having to do null checks everywhere. However, if you use the\\nNull object pattern or @NotNull you shouldn&#39;t have to.</li>\\n</ol>\\n\"}},{\"text\":\"Quick questions\",\"slug\":\"java-quick-questions\",\"fullPath\":\"/learn/languages/java/java-quick-questions\",\"content\":{\"title\":\"Quick Java questions\",\"slug\":\"java-quick-questions\",\"contents\":\"<h3 id=\\\"what-is-the-difference-between-creating-a-string-with-new-or-with-a-string-literal-\\\">What is the difference between creating a String with new() or with a String literal (&quot;&quot;)?</h3>\\n<ul>\\n<li>new() --&gt; heap</li>\\n<li>String literal --&gt; String pool</li>\\n</ul>\\n<p>The String pool is a part of the heap. Strings there are re-used.</p>\\n<pre><code class=\\\"language-java\\\">    String s1 = &quot;string pool test&quot;;\\n    String s2 = &quot;string pool test&quot;;\\n    String s3 = new String(&quot;string pool test&quot;);\\n\\n    boolean pool = (s1 == s2); // true\\n    boolean heap = (s1 == s3); // false</code></pre>\\n<h3 id=\\\"stringbuffer-vs-stringbuilder\\\">StringBuffer vs StringBuilder</h3>\\n<p>Both are used when we want to modify Strings a lot, which is not optimal with String objects since they are\\nimmutable.</p>\\n<p>StringBuilder --&gt; faster and the &quot;first choice&quot;.\\nStringBuffer --&gt; slower, but use this if you have concurrency issues.</p>\\n<h3 id=\\\"arraylist-vs-vector\\\">ArrayList vs Vector</h3>\\n<p>Concurrency --&gt; Vector is synchronized, ArrayList not.\\nPerformance --&gt; Vector is slow, ArrayList faster.\\nCapacity --&gt; Vector increases by 100%, ArrayList by 50%.</p>\\n<h3 id=\\\"arraylist-vector-vs-linkedlist\\\">ArrayList/Vector vs LinkedList</h3>\\n<p>ArrayList/Vector --&gt; when you want to index, O(1), and remove mainly from end, O(N - i).\\nLinkedList --&gt; when you want to remove from anywhere, O(1), and not index so much, O(i).</p>\\n<h3 id=\\\"implement-hashcode\\\">Implement hashCode</h3>\\n<pre><code class=\\\"language-java\\\">public class Student {\\n    boolean isCool;\\n    int age;\\n    String name;\\n\\n    @Override\\n    public int hashCode() {\\n        int prime = 31;\\n        int result = age;\\n        result = prime * result + (name != null ? name.hashCode() : 0);\\n        result = prime * result + (isCool ? 1 : 0);\\n        return result;\\n    }\\n}</code></pre>\\n<pre><code class=\\\"language-java\\\">public class Student {\\n    boolean isCool;\\n    int age;\\n    String name;\\n\\n    @Override\\n    public int hashCode() {\\n        HashCodeBuilder builder = new HashCodeBuilder();\\n        builder.append(isCool);\\n        builder.append(age);\\n        builder.append(name);\\n        return builder.toHashCode();\\n    }\\n}</code></pre>\\n<h3 id=\\\"what-do-the-different-access-modifiers-do-\\\">What do the different Access Modifiers do?</h3>\\n<p>public --&gt; any class can use.\\nprotected --&gt; classes in the same package and subclasses in any package can use.\\nprivate --&gt; only this class can use.\\nno modifier (&quot;package private&quot;) --&gt; only classes in the same package can use.</p>\\n<h3 id=\\\"which-access-modifier-should-you-use-if-only-subclasses-should-have-access-\\\">Which Access Modifier should you use if only subclasses should have access?</h3>\\n<p>Use protected and have a separate package for the class hierarchy.</p>\\n<h3 id=\\\"what-is-a-checked-exception-\\\">What is a checked exception?</h3>\\n<p>Usually caused by user error or a problem that can&#39;t be foreseen by the programmer.\\nAny subclass of Exception except for RuntimeException.\\nMust be surrounded by try/catch or declared by throws.</p>\\n<h3 id=\\\"what-is-an-unchecked-exception-\\\">What is an unchecked exception?</h3>\\n<p>Programming error.\\nAny subclass of RuntimeException.\\nCan be surrounded by try/catch or declared by throws but this isn&#39;t necessary.</p>\\n<h3 id=\\\"give-an-example-usage-of-finally\\\">Give an example usage of finally</h3>\\n<p>Usually for cleanup, such as closing sockets, db connections etc.</p>\\n<h3 id=\\\"how-can-you-create-concurrent-threads-in-java-\\\">How can you create concurrent threads in Java?</h3>\\n<pre><code class=\\\"language-java\\\">TestRunnable a = new TestRunnable(&quot;A&quot;);\\nTestRunnable b = new TestRunnable(&quot;B&quot;);\\nTestRunnable c = new TestRunnable(&quot;C&quot;);\\n\\na.start();\\nb.start();\\nc.start();</code></pre>\\n<h3 id=\\\"what-class-can-you-use-if-you-want-to-store-unique-objects-in-some-order-\\\">What class can you use if you want to store unique objects in some order?</h3>\\n<p>A TreeSet. No duplicates are stored and they are ordered with respect to compareTo().</p>\\n<h3 id=\\\"what-is-a-final-class-method-\\\">What is a final class/method?</h3>\\n<p>Final class --&gt; can&#39;t have subclasses.\\nFinal method --&gt; can&#39;t be overridden.</p>\\n\"}},{\"text\":\"Sorting\",\"slug\":\"java-sort\",\"fullPath\":\"/learn/languages/java/java-sort\",\"content\":{\"title\":\"Sorting in Java\",\"slug\":\"java-sort\",\"contents\":\"<h3 id=\\\"arrays-lambda\\\">Arrays &amp; Lambda</h3>\\n<pre><code class=\\\"language-java\\\">Meeting[] meetings = new Meeting[] {new Meeting(3, 4), new Meeting(5, 7), new Meeting(4, 6)};\\nList&amp;lt;Meeting&amp;gt; meetingsList = Arrays.asList(new Meeting(3, 4), new Meeting(5, 7), new Meeting(4, 6));\\n\\n// Sort by start time of meeting with lambda expression sort.\\nArrays.sort(meetings, (Meeting o1, Meeting o2) -&gt; o1.start - o2.start);\\nCollections.sort(meetingsList, (Meeting o1, Meeting o2) -&gt; o1.start - o2.start);\\n\\n// Alternatively skip the Collections sort and use the List instead.\\nmeetingsList.sort((o1, o2) -&gt; o1.start - o2.start);</code></pre>\\n<h3 id=\\\"comparator\\\">Comparator</h3>\\n<pre><code class=\\\"language-java\\\">Meeting[] meetings = new Meeting[] {new Meeting(3, 4), new Meeting(5, 7), new Meeting(4, 6)};\\nList&amp;lt;Meeting&amp;gt; meetingsList = Arrays.asList(new Meeting(3, 4), new Meeting(5, 7), new Meeting(4, 6));\\n\\n// Sort by start time of meeting with Comparator anonymous class.\\nArrays.sort(meetings, new Comparator&amp;lt;Meeting&amp;gt;() {\\n    @Override public int compare(Meeting o1, Meeting o2) {\\n        return o1.start - o2.start;\\n    }\\n});\\n\\n// Sort by start time of meeting with Comparator anonymous class.\\nCollections.sort(meetingsList, new Comparator&amp;lt;Meeting&amp;gt;() {\\n    @Override public int compare(Meeting o1, Meeting o2) {\\n        return o1.start - o2.start;\\n    }\\n});</code></pre>\\n\"}}],\"fullPath\":\"/learn/languages/java\"}],\"fullPath\":\"/learn/languages\"},{\"route\":\"datastructures\",\"text\":\"Datastructures\",\"children\":[{\"text\":\"Binary tree\",\"slug\":\"binary-tree\",\"fullPath\":\"/learn/datastructures/binary-tree\",\"content\":{\"title\":\"Binary tree\",\"slug\":\"binary-tree\",\"contents\":\"<p>More information is coming!</p>\\n\"}},{\"text\":\"Prefix tree\",\"slug\":\"prefix-tree\",\"fullPath\":\"/learn/datastructures/prefix-tree\",\"content\":{\"title\":\"Prefix tree (Trie)\",\"slug\":\"prefix-tree\",\"what\":\"A prefix tree (also called trie, digital tree or radix tree) is a kind of search tree. A node's position defines its key (the root's key is an empty string). All the descendants of a node have a common prefix.\",\"averageTime\":\"O(M) --> M = number of characters in input search string.\",\"contents\":\"<h3 id=\\\"what-does-it-look-like-\\\">What does it look like?</h3>\\n<p>Below is an example of a prefix tree / trie.</p>\\n<img src=\\\"/prefix-tree.png\\\" height=\\\"200\\\">\\n\\n<p>Or transform it into a Minimized DFA (Deterministic Finite Automation)...</p>\\n<img src=\\\"/prefix-tree2.png\\\" height=\\\"200\\\">\\n\\n<h3 id=\\\"example-applications\\\">Example applications</h3>\\n<p>Prefix trees are good for implementing autocomplete.</p>\\n\"}},{\"text\":\"Splay\",\"slug\":\"splay\",\"fullPath\":\"/learn/datastructures/splay\",\"content\":{\"title\":\"Splay\",\"slug\":\"splay\",\"what\":\"A self-balancing BST (other examples are AVL & Red-Black). Used in many applications, like gcc compiler, Unix malloc etc.\",\"how\":\"When a node is searched and found, it's moved to root. | If not found, the null parent is moved to root.\",\"contents\":\"<h3 id=\\\"why-\\\">Why?</h3>\\n<p>Worst case for BST is O(N) when a tree is heavily unbalanced. Splay trees keep themselves balanced AND also makes\\nsure common keys/nodes are at the top.</p>\\n<h3 id=\\\"time-complexity\\\">Time complexity</h3>\\n<ul>\\n<li>Accessing recently accessed item: O(1).</li>\\n<li>Average for all operations: O(log N).</li>\\n</ul>\\n\"}}],\"fullPath\":\"/learn/datastructures\"},{\"route\":\"other\",\"text\":\"Other\",\"children\":[{\"text\":\"Bit operations\",\"slug\":\"bit-operations\",\"fullPath\":\"/learn/other/bit-operations\",\"content\":{\"title\":\"Bit operations\",\"slug\":\"bit-operations\",\"contents\":\"<h3 id=\\\"and\\\">AND</h3>\\n<ul>\\n<li>0 if ANY bit is 0</li>\\n<li>1 otherwise</li>\\n</ul>\\n<pre><code class=\\\"language-java\\\">int a = 60; // 00111100\\nint b = 13; // 00001101\\n\\n// Result: a AND b = 00001100 = 12.\\nint c = a &amp; b;\\n\\n// Use case 1: check a certain bit.\\nint checker = 8; // 00001000\\nif ((b &amp; checker) &gt; 0) {\\n    System.out.println(&quot;Bit nr 3 is 1.&quot;);\\n} else {\\n    System.out.println(&quot;Bit nr 3 is 0.&quot;);\\n}\\n\\n// Use case 2: insert 0 somewhere.\\nint insert = 254; // 11111110\\nint d = b &amp; insert; // 00001100 = 12</code></pre>\\n<h3 id=\\\"or\\\">OR</h3>\\n<ul>\\n<li>1 if first OR second bit is 1</li>\\n<li>0 otherwise</li>\\n</ul>\\n<pre><code class=\\\"language-java\\\">int a = 60; // 00111100\\nint b = 13; // 00001101\\n\\n// Result: a OR b = 00111101 = 61.\\nint c = a | b;\\n\\n// Use case: insert 1 somewhere.\\nint insert = 1; // 00000001\\nint d = a | insert; // 00111101 = 61</code></pre>\\n<h3 id=\\\"xor-exclusive-or\\\">XOR - Exclusive OR</h3>\\n<ul>\\n<li>1 if both bits are exclusive (10 or 01)</li>\\n<li>0 otherwise</li>\\n</ul>\\n<pre><code class=\\\"language-java\\\">int a = 60; // 00111100\\nint b = 13; // 00001101\\n\\n// Result: a XOR b = 00110001 = 49.\\nint c = a ^ b;</code></pre>\\n<h3 id=\\\"not\\\">NOT</h3>\\n<ul>\\n<li>Get the inverse of a binary number</li>\\n<li>Important: sign bit is also included, so the number switches sign</li>\\n</ul>\\n<pre><code class=\\\"language-java\\\">int a = 60; // 00111100\\n\\n// Result: NOT a = 1...11000011 = -61.\\nint c = ~a;</code></pre>\\n<h3 id=\\\"shift\\\">SHIFT</h3>\\n<ul>\\n<li>Shifts bits N steps to the left/right</li>\\n</ul>\\n<pre><code class=\\\"language-java\\\">int a = 60; // 00111100\\nint b = 13; // 00001101\\n\\nint c = a &lt;&lt; 2; // 11110000 = 240\\nint d = a &gt;&gt; 2; // 00001111 = 15</code></pre>\\n\"}}],\"fullPath\":\"/learn/other\"}]}},\"path\":\"learn\",\"sharedData\":{},\"siteData\":{\"title\":\"code-yay\"}}");</script><script defer="" type="text/javascript" src="https://codercatch.com/templates/Users/Nina/git/code-yay/src/containers/Learn.tsx.491b9dad.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/templates/vendors~main.77f775ef.js"></script><script defer="" type="text/javascript" src="https://codercatch.com/main.54a1ef68.js"></script></body></html>