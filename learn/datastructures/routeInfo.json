{"path":"learn/datastructures","templateID":2,"sharedPropsHashes":{},"localProps":{"node":{"route":"datastructures","text":"Datastructures","children":[{"text":"Binary tree","slug":"binary-tree","fullPath":"/learn/datastructures/binary-tree","content":{"title":"Binary tree","slug":"binary-tree","contents":"<p>More information is coming!</p>\n"}},{"text":"Prefix tree","slug":"prefix-tree","fullPath":"/learn/datastructures/prefix-tree","content":{"title":"Prefix tree (Trie)","slug":"prefix-tree","what":"A prefix tree (also called trie, digital tree or radix tree) is a kind of search tree. A node's position defines its key (the root's key is an empty string). All the descendants of a node have a common prefix.","averageTime":"O(M) --> M = number of characters in input search string.","contents":"<h3 id=\"what-does-it-look-like-\">What does it look like?</h3>\n<p>Below is an example of a prefix tree / trie.</p>\n<p><img src=\"/prefix-tree.png\" height=\"200\"></p>\n<p>Or transform it into a Minimized DFA (Deterministic Finite Automation)â€¦</p>\n<p><img src=\"/prefix-tree2.png\" height=\"200\"></p>\n<h3 id=\"example-applications\">Example applications</h3>\n<p>Prefix trees are good for implementing autocomplete.</p>\n"}},{"text":"Splay","slug":"splay","fullPath":"/learn/datastructures/splay","content":{"title":"Splay","slug":"splay","what":"A self-balancing BST (other examples are AVL & Red-Black). Used in many applications, like gcc compiler, Unix malloc etc.","how":"When a node is searched and found, it's moved to root. | If not found, the null parent is moved to root.","contents":"<h3 id=\"why-\">Why?</h3>\n<p>Worst case for BST is O(N) when a tree is heavily unbalanced. Splay trees keep themselves balanced AND also makes\nsure common keys/nodes are at the top.</p>\n<h3 id=\"time-complexity\">Time complexity</h3>\n<ul>\n<li>Accessing recently accessed item: O(1).</li>\n<li>Average for all operations: O(log N).</li>\n</ul>\n"}}],"fullPath":"/learn/datastructures"}}}
